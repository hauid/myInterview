### 常见题

三大范式:

第一范式（1NF）：原子性（存储的数据应该具有“不可再分性”）

第二范式（2NF）: 唯一性 (消除非主键部分依赖联合主键中的部分字段)（一定要在第一范式已经满足的情况下）

第三范式（3NF）：独立性，消除传递依赖(非主键值不依赖于另一个非主键值)





#### B+ 树

B+ 树是一种**平衡多路查找树**，其灵感源自平衡二叉树和 B 树，但专为**速度较慢的“外存”**设计，因此具有独特的设计方向：

> **尽量减少数据不断增长时的磁盘 I/O 数量**，包括插入新数据场景和查询场景。

它将经典平衡二叉树的“再平衡”过程颠倒过来了——最底层的叶子节点紧密排列，新增数据时不断添加新的叶子节点，需要再平衡的不是叶子节点，而是上面的**索引页**。而索引页具有以下特点：

1. **索引页数量少**
2. 再平衡时，B+ 树算法调整的索引节点数量也很少
3. 索引容量足够大：**3 层索引可承载 2000 万行数据**，**4 层索引可承载 200 多亿行**
4. 索引页少，可以将**所有索引全部载入内存**，读取索引的磁盘 I/O 趋近于 0



​	B+ 树上层的所有页只存储索引，只用最底层的页存储数据。这是 B+ 比 B 树优秀的地方：**以一丢丢写入速度为代价，让较少的索引层数内存下了更多的索引指针，可以支撑海量的数据行数**。



B+树只有叶子和索引节点都满了,才会考虑加入新的一层

跳表是否增加层数依靠随机函数,第一层100%,第二层50%,第三层25%



B+树而非跳表:

底层都是数据都适合范围查询

- b+树是多叉树高度小,磁盘io少,读入快,使用跳表会高度很高,io大

- 跳表无需维护索引,写入性能更好,读不行





**1.原子性**
事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。

**事务机制实现,undolog**



**2.一致性**(不可中断)
事务执行的结果**必须是使数**据库从一个一致性状态变成另一个一致性状态。因此当数据库指包含成功事务提供的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分一写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如，在银行中有A、B两个账号，现在公司想从账号A中取出一万元，存入账号B中。那么就可以定义一个事务，改事务包括两个操作，第一个操作是从账号A中减去一万元，第二个操作是向账号B中加入一万元。这两个操作要么全做，要么全不做。全做或者全不做，数据库都处于一致性状态。如果只做一个操作则用户逻辑上就会发生错误，少了一万元，这时数据库就初一不一致性状态。可见**一致性与原子性**密切相关。



**3.隔离性**
一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。

**mvcc+锁实现**



**4.持续性**
持续性也称永久性（Permanence），指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。

binglog









事务是恢复和并发控制的基本单位。所以下面的考虑均与事务为对象。保证事务ACID特性是事务管理的重要任务。事务ACID特性可能遭到破坏的因素有：
**（1）多个事务并行运行时，不同事务的操作交叉执行；**
**（2）事务在运行过程中被强行停止。**

​	在第一种情况下，数据库管理员必须保证多个事务的交叉运行不影响这些事务的原子性。在第二种情况下，数据库管理员必须保证被强行终止的事务对数据库和其他事务没有任何影响。
这些就是数据库管理系统中恢复机制和并发控制机制的责任。



#### 定位慢查询:

接口压测响应时间过长,**超过5s**

方案一:开源工具

- 调试工具:Arthas	命令,跟踪方法,查看方法执行时间
- 运维监控工具:Prometheus	skywalking 看接口时间,最终定位为sql问题



==按照方案二来==

**方案二**:调试阶段,使用MySQL自带慢日志,在/etc/my.cnf配置

**//1.打开慢日志查询开关**

slow_query_log = 1

**//2.设置慢日志查询时间为**2s,超过2s视为慢查询,单位秒,默认为10s

long_query_time = 2	



explain方法查看执行计划



#### SQL执行慢,如何分析

#### **查询慢排查:**

- 先从流程说起:

  连接管理模块:管理连接

  分析器:检查SQL语法错误

  优化器:选择索引

  执行器:调用存储引擎的接口函数

- 一般是**优化器选错索引**导致,通过explain命令排查
- 客户端和MySQL内部**连接数过少**,大量请求会被阻塞等待(有些sql很久,但单独很快几ms)

​		多建连接,MySQL端默认为100

对MySQL端连接MySQL内部:set global max_connections = 500;  //默认100,改为500





<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250308234730786.png" alt="image-20250308234730786" style="zoom:33%;" />

对应用侧连接:应用侧与mysql连接 原理是基于tcp的长连接,有长连接池,通过ORM库进行**调大连接池数量**

- buffer pool 太小

​		查看**缓存命中率**(show status like 'innodb_buffer_pool_%'),一般命中率都在99%以上,低于才调大



#### 索引(重点题)

按照应用维度划分：

- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
- 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。



MySQL 8.x 中实现的索引新特性：

- 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。
- 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。
- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。



​		如果一个索引**包含所有需要的查询的字段的值**，我们称之为覆盖索引。覆盖索引是非常有用的工具，能够极大的提高性能。因为，只需要读取索引，而无需读表，极大减少数据访问量，这也是不建议使用Select * 的原因。



#### **最左匹配原则**

数据库索引设计中的一个重要概念，尤其是在使用MySQL数据库时。这个原则指出，在创建多列索引时，索引会从最左边的列开始匹配，直到遇到范围查询（如*>*、*<*、*between*、*like*等）为止。这意味着，如果查询条件中没有使用最左边的列，那么索引将不会被有效利用。





#### 索引优化

字段类型区分度比较高,尽量去避免索引失效的场景

尽量避免select *

索引覆盖

索引下推

注意避免冗余索引





#### 分库分表

分库:并发量问题,连接数不够用,一般水平,也可以读写分离

分表:单表索引效率太低了,一般水平,也可以做冷热分离



#### 索引下推

**索引下推（Index Condition Pushdown，简称 ICP）** 是 **MySQL 5.6** 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 `WHERE`字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率





#### 索引失效

创建了组合索引，但查询条件未遵守最左匹配原则;

在索引列上进行计算、函数、类型转换等操作;

以 % 开头的 LIKE 查询比如 `LIKE '%abc';`;

查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;

IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);

发生隐式转换



#### MySQL在以下情况下会使用索引：

1.查询条件中的**关键字**：当查询条件中使用了某个字段的关键字，且**该字段上建立了索引**时，MySQL会尝试使用索引来加速查询。例如，使用WHERE子句中的=、>、<、>=、<=等操作符进行条件筛选时，如果相关字段有索引，MySQL通常会利用这些索引。
2.**联接**操作：在进行表联接（如JOIN操作）时，如果联接条件中的字段有索引，MySQL会尝试使用这些索引来加速联接过程。
3.**排序和分组**操作：当使用ORDER BY或GROUP BY子句时，如果排序或分组的字段有索引，MySQL可能会利用这些索引来优化排序和分组操作。
4.**覆盖索引**：如果一个查询只需要访问索引中的信息，而无需回表查询原始数据，那么这个索引被称为覆盖索引。当MySQL检测到可以使用覆盖索引时，它会优先使用覆盖索引，因为这样可以避免回表操作，从而提高查询效率。
5.**唯一性约束和主键约束**：在MySQL中，为表的主键和具有唯一性约束的字段自动创建索引。这些索引不仅用于加速查询，还用于确保数据的唯一性。
	虽然索引可以提高查询性能，但它们也会占用额外的磁盘空间，并可能降低写操作的性能（INSERT、UPDATE和DELETE操作）。因此，在创建索引时，需要权衡查询性能与存储和写操作的开销。通常建议只对经常用于查询条件、排序、分组或联接操作的字段创建索引。同时，可以通过定期分析查询性能和数据访问模式来确定哪些索引是最有益的。



#### **最左匹配原则**

最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。



#### 什么是回表查询？

回表查询发生在使用索引检索数据时，索引本身并不包含所有需要的字段。在这种情况下，数据库首先使用索引找到相关的行的位置（通常是行ID），然后使用这些**行ID**再次查询（回表）到数据表中检索完整的行数据。



#### 为什么需要回表？

在关系型数据库中，表数据可以通过两种方式存储：**聚集和非聚集**。在聚集索引中，表记录按照索引的顺序存储在磁盘上。对于非聚集索引，索引结构和数据实际存储是分开的。非聚集索引的查询通常需要回表操作，因为索引本身只存储了指向实际数据行的指针（例如，行ID）。





#### 回表查询的影响

**性能开销**：回表查询需要额外的数据访问步骤，因此可能比覆盖索引查询（索引包含所有需要的字段，无需回表）更慢。





#### 锁

实现隔离性

读 读	不加锁

写 写	通过加锁

读 写	通过mvcc实现

**根据思想**			乐观,悲观锁

**根据性质**		共享锁(for share),	独占锁(for update)

**根据粒度分类**			全局锁,行锁,表锁

全局锁 锁定所有的表(数据备份)

表锁 	

- 意向锁     防止加表锁时**一行一行去看行锁的加锁情况**

​		插入意向锁属于共享锁 行加了gap锁 其他事务要插入就需要加入**表意向锁**

- lock tables 显式加锁
- 元数据锁  防止DML和DDL冲突,隐式加的锁

行锁

**行锁三种type**

行锁 innodb 主键

- **精准行锁** 	主键或唯一索引的等值查询



- **间隙锁即gap锁** 锁行与行之间间隙

  一般是针对有索引的等值查询且未命中会触发



- **临键锁即nextkey锁** inoodb对有索引的范围查询会使用，对索引和数据锁定区间左开右闭范围
  由间隙锁 + 记录锁(**精准行锁** )组成，锁定区间并包含下一个记录。例如，若索引有值10和20，临键锁会锁定`(10, 20]`的区间（即间隙`(10, 20)`和记录20本身）





**应用场景:**



**ReadView**:主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”

**快照读**：由 MVCC 机制来保证不出现幻读。

**当前读**：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁

| 隔离级别 | 读数据             | mvcc                                    | 更新数据                                         |
| -------- | ------------------ | --------------------------------------- | ------------------------------------------------ |
| 读未提交 | 读取数据不加锁     | **当前读**                              | 更新数据使用**共享行锁**                         |
| 读已提交 | 读取数据不加锁     | 快照读,每次查询都会构造一个新的readview | 更新使用**独占行锁**                             |
| 可重复读 | 读取数据不加锁     | 快照读,只在首次查询生成readview         | 更新数据配合**nextkey行锁**解决部分幻读问题，    |
| 串行读   | 读取加**共享表锁** | **当前读**                              | 更新数据**加独占表锁**，解决所有事务问题，效率低 |





#### MySQL事务隔离备注

**脏读** a读到b事务还没提交的数据
**不可重复读** a读到b事务提交的数据，a读到的前后不一致
**幻读**  a读取集合，b在事务中增加或删除数据，a读到的前后数量不一致 



**Read uncommitted:脏读,不可重复读,幻读**
**Read committed:不可重复读,幻读**
**Repeatable Read(默认):幻读** 
**Serializable:无问题**





`InnoDB`存储引擎在 RR 级别下通过 `MVCC`和 `Next-key Lock` 来解决幻读问题：

**1、执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据**

在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”

**2、执行 select...for update/lock in share mode、insert、update、delete 等当前读**

在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 **Next-key Lock**来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读



**1.原子性**
事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。

**事务机制实现,undolog**

**2.一致性**(不可中断)
事务执行的结果**必须是使数**据库从一个一致性状态变成另一个一致性状态。因此当数据库指包含成功事务提供的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分一写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如，在银行中有A、B两个账号，现在公司想从账号A中取出一万元，存入账号B中。那么就可以定义一个事务，改事务包括两个操作，第一个操作是从账号A中减去一万元，第二个操作是向账号B中加入一万元。这两个操作要么全做，要么全不做。全做或者全不做，数据库都处于一致性状态。如果只做一个操作则用户逻辑上就会发生错误，少了一万元，这时数据库就初一不一致性状态。可见**一致性与原子性**密切相关。

**3.隔离性**
一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。

**写和写之间通过加锁实现,读和写通过mvcc+锁实现**

**4.持续性**
持续性也称永久性（Permanence），指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。

binglog





#### MVCC

multi-version concurrency control多版本并发控制

实现高效且一致的数据访问，**读取数据的时候不加锁，也可以读取到一致的数据，而且允许读和写同时进行，解决了传统并发控制方法下锁占用与阻塞导致的性能问题**

**undo Log**来实现多版本并发控制(MVCC)。当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据版本是怎样的，从而让用户能够读取到当前事务操作之前的数据

**总结:undo log(实现原子性)+Readview实现**







#### undolog过程和回滚链

SQL先在磁盘写入undolog(保**证能够使用undolog**),再访问内存

 <img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250330214209009.png" alt="image-20250330214209009" style="zoom: 67%;" />



二分法 非常不准 脱离理论 基于"认知功能"划分

认为认知功能天生的?

解释为源动力,驱使你行动的力量

官杀 压力 恐惧

食商 表现出来的东西



undolog链头部两个重要参数:1.trx_id事务id 2.roll_pointer指向上个版本的指针

通过roll_pointer实现undo链

新增:通过指针关联undolog

删除和更新:更加复杂一点

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250330212654171.png" alt="image-20250330212654171" style="zoom:50%;" />



#### read view 读视图

一个内存结构,事务select查询数据时

四个步骤判断:

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250330212510800.png" alt="image-20250330212510800" style="zoom:50%;" />









#### MySQL超大分页怎么处理

limit分页查询时需要**对数据进行排序,效率低**

![image-20250310124131229](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310124131229.png)

**覆盖索引加子查询优化**

![image-20250310135141440](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310135141440.png)

先根据id排序(用的覆盖索引) 再和 之前要查的表 关联做 **等价查询**



#### 



#### 字符串适合做一个主键索引 



#### innodb索引是怎么实现的 



#### 树涉及到层高，有没有优化的算法限制层高 



#### 限制层高有什么好处？



### 底层题

#### Mysql是什么？ 

​	关系型数据库数据库,类似excl表格的形式存储数据



#### 数据页是什么？ 

​	.ibd文件中 	大小对应磁盘的数据页 	对应计组中一个外存的数据块





#### Mysql数据页为什么是16KB. B+树是什么？ 

 	InnoDB 出现的时候，SSD 还没有出现，所以它是为了机械磁盘及其 512 字节的扇区而设计的，所以页块的默认大小被设置为了 16KB（32 个连续扇区）

**对应一个外存数据块大小 占14位**

**一种数据结构,在mysql中实现可以用来数据叶跟叶之间加速查找数据页**





#### 索引页是什么？ 

**根据每个数据块第一项数据的索引(主键索引),**

**且具有多层结构**

**对应B+树的实现类**





#### Buffer Pool是什么？ 

读磁盘还是太慢了,再加一层进程内缓存,进程内缓存存储16KB数据和索引页

**读数据优先读buffer Pool**

**进程自己维护的Buffer Pool可以定制更多的缓存策略,实现加锁,通过直接IO模式,无需os的文件缓存(内核空间)**

**(`缓存I/O` 的优点是减少对块设备的 I/O 操作，而缺点就是需要多一次的内存复制。另外，有些应用程序需要自己管理 I/O 缓存的（如数据库系统），那么就需要使用 `直接I/O` 了。)**





#### 自适应哈希索引是什么？ 

某页被多次访问，自动为该页构建哈希索引，将键值直接映射到数据位置，避免B+树逐层搜索



#### Change Buffer是什么？ 





#### Undo log(回滚日志)是什么？

**针对事务的原子性质**

旧数据生成undo log记录存入undo log内存页
特殊内存页面,**,刷盘不定时写入磁盘undo log文件**



**作用**

**1.提供回滚,记录反向操作的语句**

2.undo Log来实现多版本并发控制(MVCC)。**当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据版本是怎样的**，从而让用户能够读取到当前事务操作之前的数据



#### Redo log是什么？

**针对事务的原子性质**

内存只写一半到磁盘中数据库崩溃问题,**更新操作全写到redo log buffer中**,事务提交时刷磁盘,写入磁盘速度快(**顺序追加写,是随机写磁盘的几十倍**)

更新数据,**事务提交**的时候进行**刷磁盘,固化数据**

通过找到relog重做数据,**保证事务的一致性**



**缺点**

- **循环写的，日志空间固定，写满后会覆盖旧日志，短期恢复的机制**
- **redo log 只适用于 InnoDB,binlog 适用于 所有存储引擎（如 MyISAM）**
- **redo log 无法进行主从复制，MySQL 的主从同步机制依赖 binlog。**





#### Binlog是什么？ 

**防止数据库被删除,记录所有操作到日志文件中**,采用的是**追加写方式，不具有幂等性**。

**缺点**

- binlog 只是**逻辑日志，记录的是SQL 语句或行级变更，但不保证事务的持久性**。
- binlog 写入时机比 redo log 晚，如果数据库崩溃，binlog 可能还没来得及写入，导致数据丢失。 binlog 只能用于恢复和同步，不提供崩溃恢复功能，因此不能替代 redo log。



#### 总结：为什么 MySQL 需要 redo log 和 binlog ？ 

redo log 解决的是 崩溃恢复 问题，保证**事务的持久性**。 
binlog 解决的是 数据恢复、主从复制 问题，记录所有数据变更，确保主从同步和时间点恢复（PITR）。 
MySQL 事务提交的顺序是 先写 **redo log，再写 binlog**，确保数据一致性。 所以，redo log 和 binlog 各司其职，不能互相替代！

###

回滚 vs 闪回

redo log 是循环写的，日志空间固定，写满后会覆盖旧日志，无法用于长期数据恢复。

 redo log 无法进行主从复制，MySQL 的主从同步机制依赖 **binlog**





#### InnoDB是什么？ 

buffer pool 

redo log buffer

redo log文件

undo log文件

*.ibd文件

共同构成innodb引擎,对外提供函数接口





#### Serve层

**用户和存储引擎中间层**

连接器(**管理网络连接**)

分析器(**判断语法错误**)

优化器(**索引)**

执行器(**生成执行计划,调用函数接口**)



#### Myisam是什么？ 

早期的引擎







#### 数据库查询流程 数据库更新流程

**读操作**,先检查内存中是否有所需要的B+树数据页,不存在从磁盘读取

对于热点数据加入**自适应哈希索引**

**写操作**,先写入buffer pool生成相应的undo log记录

再写入redo log buffer,redo log会周期性写入磁盘redo log文件

对于辅助索引的更新操作

**会将更新暂时存储在change buffer中,等到相关的索引页被读入buffer pool再继续实际的更新操作,减少io,**

**所有操作都会记录在binlog中,进行数据恢复**





#### undo-log

`undo log` 主要有两个作用：

- 当事务回滚时用于将数据恢复到修改前的样子
- 另一个作用是 `MVCC` ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据，以此实现非锁定读





事务的四大特性主要是：**原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） acid**



1.原子性
事务是数据库的逻辑工作单位，事务中包括的诸操作**要么都做，要么都不做。**

2.一致性
事务执行的结果必须是使**数据库从一个一致性状态变成另一个一致性状态**。因此当数据库指包含成功事务提供的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分一写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如，在银行中有A、B两个账号，现在公司想从账号A中取出一万元，存入账号B中。那么就可以定义一个事务，改事务包括两个操作，第一个操作是从账号A中减去一万元，第二个操作是向账号B中加入一万元。这两个操作要么全做，要么全不做。全做或者全不做，数据库都处于一致性状态。如果只做一个操作则用户逻辑上就会发生错误，少了一万元，这时数据库就初一不一致性状态。可见一致性与原子性密切相关。

3.隔离性
一个事务的执行不能被其他事务干扰。即一个**事务内部的操作及使用的数据对其他并发事务是隔离的**，并发执行的各个事务之间不能相互干扰。

4.持续性
持续性也称永久性（Permanence），指一个事务一旦提交，它对数据库中的数据的**改变就应该是永久性的**。接下来的其他操作或故障不应该对其执行结果有任何影响。
事务是恢复和并发控制的基本单位。所以下面的考虑均与事务为对象。
保证事务ACID特性是事务管理的重要任务。事务ACID特性可能遭到破坏的因素有：
（1）多个事务并行运行时，不同事务的操作交叉执行；
（2）事务在运行过程中被强行停止。
在第一种情况下，数据库管理熊必须保证多个事务的交叉运行不影响这些事务的原子性。在第二种情况下，数据库管理熊必须保证被强行终止的事务对数据库和其他事务没有任何影响。
这些就是数据库管理系统中恢复机制和并发控制机制的责任。

















