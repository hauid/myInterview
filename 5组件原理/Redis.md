#### 概念:

Redis是用**C语言**开发的一个开源的高性能**键值对(key-value)数据库**，官方提供的数据是可以达到**100000+**的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为**结构化的NoSql数据库**。

 

模板设计模式

**Spring Data Redis**中提供了一个高度封装的类：**RedisTemplate**，对相关api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：

- ValueOperations：string数据操作

- SetOperations：set类型数据操作

- ZSetOperations：zset类型数据操作

- HashOperations：hash类型的数据操作

- ListOperations：list类型的数据操作






#### Redis缓存技术快的底层原理

- **多使用了一些内存空间，提升了系统的响应速度，这就是空间换时间**。
- 由于**内存必然比磁盘的读写速度快**、读写延迟低，所以我们只要把热门数据和计算结果存储在内存中，就可以提高数据的读取速度，进而提升系统总体性能。

- **单线程避免上下文切换**：单线程无需处理多线程切换
- **非阻塞I/O技术**(展开说)



#### 对比MySQL

​	Redis 单机的 QPS 能轻松破 **10w**，而 MySQL **单机的 QPS 很难破 1w**。



#### 数据类型



##### Zset 类型

Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。

在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。

排行榜

有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。





##### bitmap

bitmap场景

签到统计

在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。

签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。

假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。





#### **为什么不用数据库B+树的数据结构**

**1.读写性能:**

​	Redis 需要支持非常高速的读写操作。虽然 B+ Tree 提供了良好的搜索效率（通常是 O(log n)），但是在**内存中，简单的数据结构如哈希表可以提供接近 O(1) 的时间复杂度**，这对于 Redis 这样对性能要求极高的系统来说更有优势。

**2.数据类型多样性**

​	Redis 不仅仅存储键值对，它还支持列表、集合、哈希表等多种数据类型。这种数据类型的多样性要求 Redis 使用更灵活、更适合各种数据类型的内部数据结构。**B+ Tree 主要优化了范围查询和顺序访问**，这在 Redis 的使用场景中不是最主要的需求。

**3.操作简便性**

​	B+ Tree 的**维护**（如节点分裂和合并）相对复杂，这在**高并发和高性能**的环境下可能成为一个瓶颈。Redis 使用更简单的数据结构可以减少这种复杂性，提高操作的效率。





#### **为什么单线程还能高效处理高并发？**

1. **内存操作**：数据存储在内存中，单次操作耗时极短（微秒级）。
2. **非阻塞I/O**：使用**多路复用（epoll/kqueue）处理网络I/O**，避免等待客户端响应。
3. **避免上下文切换**：单线程无需处理多线程切换开





![image-20250306141549143](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250306141549143.png)



​	**对于读写命令来说，Redis 一直是单线程模型**。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了**多线程来处理网络请求（提高网络 IO 读写性能）.**









#### Redisson分布式锁

基于Redisson分布式锁 （**Redis 的可重入锁 RLock,非公平锁**），对每一次请求进行唯一性校验。



#### 过期数据的删除策略

常用的过期数据的删除策略就下面这几种：

1. **惰性删除**：只会在取出/查询 key 的时候才对数据进行过期检查。这种方式对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除**：周期性地**随机**从设置了过期时间的 key 中抽查一批，然后逐个检查这些 key 是否过期，过期就删除 key。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。
3. **延迟队列**：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。
4. **定时删除**：每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要为每个键都设置一个定时器。







#### 大key问题

***1、redis-cli --bigkeys 查找大key***

可以通过 redis-cli --bigkeys 命令查找大 key：









**主从:**
**父子节点命令**:slave of A (IP A) (port A)
数据同步原理:
1.全量同步流程:
slave节点总是先请求**增量同步**
master节点判断**replid**,发现不一致,拒绝增量同步
master生成完整**RDB**,发送到slave
slave清空本地数据,加载**RDB**
master在RDB期间的命令记录在baklog中,持续将log中命令发给slave
slave执行接收到的命令,保持与master之间的同步

2.如果slave重启后同步,则执行增量同步(slave提交自己的offset,master获取repl_baklog中从offset之后的命令给slave)
baklog大小有上限,slave断开过久导致数据被覆盖则无法增量同步

**优化主从集群:**
master中启用无磁盘复制,避免磁盘IO
单节点内存占用不要太大,减少过多的IO
适当提高repl_baklog大小
限制master上的slave节点数量,可以采用主-从-从链式结构

哨兵:
哨兵机制来实现主从集群的自动故障恢复,作业包括监控,自动故障恢复,通知客户端

监控:**每隔一秒向集群的每个实例发送ping命令,若某实例在规定时间未响应,则认为其主观下线;若超过指定数量的哨兵认为下线,则实例客观下线**

故障转移步骤:
1)首先选举新master:首先判断slave节点与master节点断开时间,超过指定值排除;然后判断优先级的值,越小优先级越高;优先级一样判断offset值,越大说明数据越新;最后判断运行id大小,越小优先级越高
2)其他节点都slave of 新master
3)故障节点slave of 新master



#### RDB和AOF

**RDB 可以更快地进行数据恢复，因为它是直接加载快照；而 AOF 需要重新执行所有记录的命令**













### 缓存问题

#### 雪崩

​	**大量缓存数据**在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是**缓存雪崩**
针对大量数据同时过期而引发的缓存雪崩问题,常见的应对方法有下面这几种：\

​	永远设置单线程访问缓存,互斥锁?

​	**均匀设置过期时间(原有的失效时间基础上增加一个随机值)；**
​	**互斥锁；**
​	**后台更新缓存；** 

​	**双key,一个永久,一个设置备份时间**

​	**熔断,限流,高可用集群**



#### 缓存击穿(可以认为缓存击穿是缓存雪崩的一个子集)

针对某个热点数据,一个缓存中的数据因为某种原因（通常是缓存中的数据过期或者被删除），在短时间内遭受大量的请求，导致这些请求直接穿透到数据库或其他后端存储系统，增加了后端系统的负载

缓存击穿通常在以下情况下发生：

1. 热点数据**过期**：当缓存中存储的热门数据过期时，大量的请求会同时查询后端数据库。
2. **第一次请求**：对于一个之前从未被请求过的数据，当它第一次被请求时，缓存中没有这个数据，从而导致请求穿透到后端存储。



常见的方案：

- 设置热点数据**永不过期**：对于一些热点数据，可以将其永不过期，确保即使数据过期后，仍然可以从缓存中获取。

​	设置热点数据永不过期属于是业务范围应该考虑的事情，这个数据是否应该永不过期？或者说活动时设置过期时间为 -1，活动后再执行程序删除。有一点可以确认，缓存数据不可能全部都是永不过期，因为缓存的存储压力会比较大，所以该方案无法作为通用方案

- 使用互斥锁：在获取数据时，使用**分布式锁**（如 Redis 的分布式锁）来控制同时只有一个请求可以去后端获取数据，其他请求需要等待锁释放。这样可以防止多个请求同时穿透到后端存储。

​	使用互斥锁,这会造成两个实际的问题：

1. 全部用户获取锁后查询数据库，会对数据库造成无用的性能浪费，因为这 100w 的请求，只有第一次是有效的。
2. 查询数据库会造成用户响应时间变长，接口吞吐量下降。



**优化使用:双重判定锁**

​	双重判定锁是分布式互斥锁的升级版本。它在获取锁后，再次检查**缓存中是否存在数据，以避免重复查询数据库**。只有在确认缓存中不存在数据时，才继续查询数据库。







#### 缓存穿透

​	当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是**缓存穿透**的问题。



**缓存和数据库之间加一层布隆过滤器**

(**使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在**：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过**查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的**)

**(误判率问题)**



![图片](https://cdn.xiaolincoding.com//mysql/other/061e2c04e0ebca3425dd75dd035b6b7b.png)





