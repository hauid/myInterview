3.7 手游公司	Java后端游戏业务逻辑开发,排行榜设置



Spring IOC容器





**三级缓存**
第一级存放完全初**始化好**的Bean,可以直接使用

第二级存放**原始的Bean**,已经**实例化但还没有进行赋值或依赖注入**

第三级存放**Bean工厂对象**,生成原始Bean对象放入二级缓存中(工厂设计模式)

核心思想:把Bean的**实例化**和Bean**依赖注入**进行分离





**幂等性组件**



**项目中缓存和数据库一致性怎么设计**

为了满足用户对一趟列车不同站点不同座位类型的余量查询需求，我们采取了一种优化方案。我们将这些余量信息存储在缓存中，以便用户可以快速查询。

然而，在用户创建订单并完成支付时，我们需要同时从数据库和缓存中扣减相应的列车站点余票。这种设计不仅提高了查询效率，也保证了数据的一致性，确保订单操作的准确性。

背景:使用缓存，那必然要面临一致性问题。**性能和一致性**就像天平的两端，无法做到都满足要求。



**eazy:采用更新数据库和更新缓存**

- **两个线程要修改「同一条」数据，每个线程在改之前**，**先去申请分布式锁**，拿到锁的线程才允许更新数据库和缓存，拿不到锁的线程，返回失败，等待下次重试。

  **性能最低**

- 读数据加读锁(共享锁),	写数据加写锁(写锁互斥)		

  **强一致性但性能一般**	(使用redis自带的读写锁)





**medium:**

缓存双删



**写数据库,并且改动缓存**(结合双重锁)

读缓存,读缓存会有一个小周期会读到错误的缓存

当**缓存过期**（可能是缓存正常过期也可能是 Redis 内存满了触发清理策略）条件满足，同时**读请求的回写缓存 Redis 的执行周期在数据库删除之前**，那么就有可能触发缓存数据库不一致问题。





**hard:先写数据库，通过 BinLog 异步更新缓存**

这种方案是我认为最终一致性最为值得尝试以及使用的。但是有一句话说的是没有绝对合适的技术，只有相对适合的技术，这种方案实现是**也存在一些技术问题**

**比如数据库添加版本号，或者根据最后修改时间等技术规避这些问题。**

Canal 会将 Binlog 的变更内容**推送**到指定的 RocketMQ Topic。因此，在 Spring Boot 应用中，我们只需要与 RocketMQ 进行对接即可



**总结**

可以根据业务场景选择下述缓存一致性方案：

- **缓存双删**：如果公司现有消息队列中间件，可以考虑使用该方案，反之则不需要考虑。**(不考虑)**

- **先写数据库再删缓存**：这种方案从**实时性**以及技术实现复杂度来说都比较不错，推荐大家使用这种方案。(**写数据库会加锁,比较慢,别的线程来也干不了什么**)

  **(实时性要求比较高)**

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310164131654.png" alt="image-20250310164131654" style="zoom: 80%;" />



- 先写数据库，通过 BinLog 异步更新缓存

  如果希望实现**最终一致性以及数据多中心模式**，该方案无疑是最合适的。**(最终一致性)**

​	 Canal 监听 Binlog 模式。该方案将数据库的数据变更通过 Canal 转发给消息队列的特定 Topic。客户端应用程序可以监听该消息队列的 Topic，以保持缓存与数据库的一致性。



​	增加版本号解决方案：在进行修改操作时，先判断当前版本号是否小于要修改的版本号，只有在当前版本号小于目标版本号的情况下才进行修改。通过增加版本号，可以有效避免并发修改引起的数据不一致问题。



**排行榜设计**

堆可能适合维护前一千名的列表

**跳表功能:redis的zset结构**



### **关键差异对比**

| **特性**       | **跳表实现**                     | **红黑树实现**                      |
| :------------- | :------------------------------- | :---------------------------------- |
| **并发读**     | 完全无锁，多线程可同时访问       | 需要获取读锁                        |
| **并发写**     | 使用 CAS 自旋保证原子性          | 写锁独占，阻塞其他读写操作          |
| **内存布局**   | 指针数组占用更多内存             | 对象引用结构内存更紧凑              |
| **代码复杂度** | 插入逻辑简单（约 50 行核心代码） | 需要处理旋转和颜色翻转（约 200 行） |





**实时分数排行榜设计**

​	第一次可以用**快速排序**,后续对实时性要求极高，且排行榜的大小不是非常大，可以考虑使用**插入排序**，每次新数据到来时，直接在已排序的数组中找到合适的位置插入，这样可以保持数据总是排序状态。

但这种方法在数据量大时效率较低。
