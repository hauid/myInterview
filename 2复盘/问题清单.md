#### 并发三大问题





#### int 和 Integer区别



#### Java为什么不支持多继承？（这里回答的还行，不过有点生疏了）

- Java中不支持多重继承也是因为
  - Java有单一继承这样的更高层次的抽象
  - 也有实现多个接口这样的更多层次的扩展方式





#### Java实现多继承会有什么问题呢？（会过于复杂化，单一作用原则）

- 第一个原因围绕**钻石/菱形继承问题产生的歧义**，考虑一个类 A 有 foo() 方法, 然后 B 和 C 派生自 A, 并且有自己的 foo() 实现，现在 D 类使用多个继承派生自 B 和C，如果我们只引用 foo(), 编译器将无法决定它应该调用哪个 foo()。这也称为 Diamond 问题
- 多重继承会增加**代码的复杂性和维护难度**。当一个类继承自多个父类时，可能会引入大量的依赖关系和潜在的冲突，使得代码难以理解和维护。



#### Java如何弥补多重继承的限制？

- **接口**允许一个类实现多个接口，从而实现类似多重继承的效果。





#### 接口和抽象类有什么区别呢？

##### 接口和抽象类的共同点

- **实例化**：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。
- **抽象方法**：**接口和抽象类都可以包含抽象方法**。抽象方法没有方法体，必须在子类或实现类中实现。

##### 接口和抽象类的区别

- **设计目的**：接口主要用于对**类的行为**进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是**所属关系**。

- **继承和实现**：一个类**只能继承一个类（包括抽象类）**，因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。







#### String，了解吗？为什么要把他设计成不可变

String 类

String 真正不可变有下面几点原因：

1. 保存字符串的数组被 **`final` 修饰且为私有的**，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. `String` 类被 `final` 修饰导致其不能被继承，**进而避免了子类破坏 `String` 不可变**。



#### intern高速缓存怎么实现的知道吗？（我以为他说的英特尔）



#### 创建对象的方式？（构造方法，克隆，反射，序列化）



#### 为什么采用B+树而非一般的二叉树或者红黑树

- B+树分叉多,查询层级少,一般的树存储起来太高了,查询效率不高

- 叶子节点是一个双向链表,适合扫库和范围查询,适合范围查找

​		一般的树结构不适合**范围查找**





#### B+树而非b树

**背景**:B树:多路平衡查找树

​		B+树:优化B树适合实现外存结构

- b树叶子节点存数据,非叶子节点上面**只存指针**,叶子存数据,**减少一定量的磁盘io**

- 相比b树, 解决查询**性能不稳定**的问题
- b树不适合**范围查找**,b树范围查找需要在**不同层级节点**之间进进出出,效率不高

​		叶子节点是一个双向链表,适合扫库和范围查询





#### 索引

- 高效获取数据的数据结构
- 降低了数据排序的成本



#### 一级索引(聚集索引)

数据和索引**放一块**,叶子节点保存了整行数据,**有且只有一个**



#### 二级索引

数据和索引**分开存储**,叶子节点保存了对应的主键,可以有**多个**



#### 回表查询

通过**二级索引找到对应的主键值**,再到一级索引中查找**整行数据**,这个过程就是回表



#### 覆盖索引

查询中使用了索引,并且**所有需要查询的字段的值**,在该索引中已经全部能找到

使用的两种情况

- 用的主键索引查找一行的数据,即一级索引中包含数据,一次索引扫描可以直接返回,相当于用了覆盖索引,性能高
- 用的一般索引查找主键id以及对应一般索引的字段,也可以直接返回

未使用

- **返回的列中没有创建索引**,就会触发回表查询,尽量避免使用select *

##### 非覆盖索引就需要回表查询



#### MySQL超大分页怎么处理

limit分页查询时需要**对数据进行排序,效率低**

![image-20250310124131229](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310124131229.png)

**覆盖索引加子查询优化**

![image-20250310135141440](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310135141440.png)

先根据id排序(用的覆盖索引) 再和 之前要查的表 关联做 **等价查询**







#### 联合索引

使用表中的多个字段创建索引，就是 **联合索引**，也叫 **组合索引** 或 **复合索引**。



#### 分页查询优化

 最基本的分页方式：

```mysql
SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...
```

在中小数据量的情况下，这样的 SQL 足够用了，唯一需要注意的问题就是确保使用了索引。

如果实际 SQL 类似下面语句，那么在 category_id, id 两列上建立复合索引比较好。

```sql
SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10
```













#### mysql最左匹配原则（这个答好的，慢慢舒服起来了）

​	最左前缀匹配原则指的是在**使用联合索引**时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果**查询条件与索引中的最左侧字段相匹配**，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。

​	最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配





#### 回表查询

​	当使用**非主键索引**进行查询时，数据库会先找到对应的**主键值**，然后**再通过主键索引**来定位和检索完整的行数据。这个过程被称为“**回表**”





#### SQL语句执行逻辑顺序

基础

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310121022863.png" alt="image-20250310121022863" style="zoom: 80%;" />



注意事项:

- 分组**(group by)**之后，查询的字段一般为**聚合函数和分组字段**，查询其他字段无任何意义

- 执行顺序：**where > group by>聚合函数 > having** 





#### where与having区别

- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。
- 判断条件不同：where不能对聚合函数进行判断，而having可以。









#### mysql怎么查询慢查询（explain，还有show processlist）

打开慢查开关

超过long_query_time就算是慢查

看type字段,一般要达到range,范围查询级别(range -> index -> all)

rows 扫描的数据量

extra 文件排序 覆盖索引 索引下推



#### redis的AOF持久化的刷盘策略（三种，全答上来的）





#### redis内存满了，怎么做





#### 项目中用过的设计模式

讲一下单例模式



#### 有没有了解过静态内部类？（不会）

**可以用来实现单例模式**



Java 的基本数据类型和对应的字节数



讲一下 Java8 的一些新特性



讲一下 Java 集合，从集合的框架开始，然后往下逐步实现



讲一下 ConcurrentHashMap



讲一下往里面 put 放数据的过程



问一个架构方面的：比如说有一个大流量请求到你的服务上，我们从架构到代码上有哪些方法去处理？



讲一下对 Java 锁的了解



volatile 的主要作用，以及它为什么线程不安全？



MySQL 索引的数据结构（B+树）



讲一下回表是什么？



讲一下 MySQL 的 MVCC 机制



有了解 MQ 吗，平时怎么使用的？





\* 常用的设计模式。举一下自己使用过的案例
\* jdk源码和java框架中使用设计模式的例子
\* 反射的原理和使用场景
\* 注解平时怎么使用
\* SpringBoot中的核心注解讲讲原理
\* MySql索引介绍一下
\* hash和b+树索引的利弊
\* 项目的分库分表怎么做的？
\* 项目中用到的分布式锁是怎么实现的
\* 分布式锁加了一个过期时间 如果时间到了 代码没有执行完怎么办？

\* MQ的死信队列了解过吗？讲一下
\* 日志系统具体是怎么实现的
\* 现在不只是正对于某个单体项目去做这个日志记录的功能。对于任意一个服务想做日志记录的功能。怎么快速实现
\* 算法：判断链表是否成环。如果成环 返回成环的节点角标





