

# os

## 协程

协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈
协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多















# 计网

## http协议

@ResponseBody 是 Spring 中的一种注解，通常用于将方法的返回值直接写入 HTTP 响应体，而不是通过视图解析器解析为视图（如 JSP 或 HTML).
@RestController = @Controller + @ResponseBody,表示该控制器返回 JSON 数据而不是视图。适用于前后端分离或REST API 开发。

请求协议：浏览器将数据以请求格式发送到服务器。包括：请求行(**常被视为属于请求头**)、请求头 、请求体
请求行：HTTP请求中的第一行数据。由：请求方式、资源路径、协议/版本组成（之间使用空格分隔)
请求头：第二行开始,格式为key: value形式
请求体 ：存储请求参数

GET请求:请求参数在请求行中，故不需要设置请求体
POST请求 :请求参数在请求体中,需要多参数(传递对象则使用POST请求)
Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装(HttpServletRequest)，并在调用Controller方法的时候传递给了该方法。

**1)响应行**(**常被视为属于响应头**)：响应数据的第一行,响应行由协议及版本,响应状态码,状态码描述 例如：HTTP/1.1 200 OK
**2)响应头**：响应数据的第二行开始。格式为key：value形式 例如：
Content-Type: application/json
Content-Length: 1234
**3)响应体**： 响应数据的最后一部分,存储响应的数据.

Web服务器对HTTP协议的响应数据进行了封装(HttpServletResponse)，并在调用Controller方法的时候传递给了该方法
1xx	响应中 --- 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略
2xx	成功 --- 表示请求已经被成功接收，处理已完成
3xx	重定向 --- 重定向到其它地方，让客户端再发起一个请求以完成整个处理
4xx	客户端错误 --- 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等
5xx	服务器端错误 --- 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等

- 200 ok   客户端请求成功
- 404 Not Found  请求资源不存在
- 500 Internal Server Error  服务端发生不可预期的错误

## TCP,UDP

TCP（传输控制协议）和UDP（用户数据报协议）是计算机网络中传输层的两个主要协议，它们各自具有不同的特点和适用场景。以下是TCP和UDP之间的主要区别：

- 连接特性：
  TCP是面向连接的协议。在传输数据之前，需要通过三次握手来建立连接，并在数据传输完成后通过四次挥手来释放连接。这种连接机制确保了数据传输的可靠性和顺序性。
  UDP则是无连接的协议。发送数据前不需要建立连接，直接发送数据包，这使得UDP在传输数据时更加灵活和高效。
- 可靠性：
  TCP提供可靠的数据传输服务。它使用校验和、重传控制、序号标识、滑动窗口和确认应答等机制来确保数据的无差错、不丢失、不重复且按序到达。
  UDP则提供尽最大努力交付的服务，不保证数据的可靠传输。在数据传输过程中，如果发生丢包或乱序，UDP不会进行重传或顺序控制。
- 效率与实时性：
  UDP具有较好的实时性和较高的工作效率，因为它不需要建立连接和进行复杂的控制操作。这使得UDP适用于对高速传输和实时性有较高要求的通信或广播通信，如语音、视频、直播等。
  TCP虽然提供了可靠的数据传输，但由于其复杂的控制机制，相对UDP而言效率较低。
- 通信模式：
  TCP连接只能是点对点的，即一条TCP连接只能连接两个端点。
  UDP则支持一对一、一对多、多对一和多对多的交互通信模式，这使得UDP在广播和多播等场景中更具优势。
- 首部开销：
  TCP的首部较大，通常为20字节，这增加了每个数据包的开销。
  UDP的首部较小，只有8字节，减少了数据包的开销，提高了传输效率。

## 三握四挥

第一次握手：
客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。

第二次握手：
服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。

第三次握手：
客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。
第二次分手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。
第三次分手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。
第四次分手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。