## JVM

javap -v [类名]  查看字节码文件的信息



#### 变量分类

变量分为

##### **1.局部变量**

**局部变量（Local Variables）：**局部变量是在方法、构造函数或块内部声明的变量，它们在声明的方法、构造函数或块执行结束后被销毁，局部变量在声明时需要初始化，否则会导致编译错误。



##### **2.成员变量**（member variable）

**2.1实例(无static)变量**

​	在某个方法外部，类内部定义的变量，从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型默认的初始值。部分变量的默认初始值如下表所示

```java
public class TestVariable{
	int a;//成员变量，会自动初始化
	public static void main(String[] args){
		.....
		} 
}

```

##### **2.2静态(static)变量** ,类变量

​	静态变量使用static定义，从属于类，声明周期伴随类始终，从类加载时产生，类卸载时结束。如果不进行初始化，与成员变量一样，会自行初始化成该类型的默认初始值。

通过**类名.静态变量**就可以访问了，不需要创建类的实例





#### 编译器

​	Java 里的编译器可以分为**前端编译器和运行期编译器**，前端编译器是指将 .java 编译成 .class 的过程，而运行期编译器则是指将 .class 字节码转变成**机器码**的过程，而运行期编译器的英文为 Just In Time Compiler，所以又能简称为 JIT 编译器





#### 类和对象在内存中的存储

- **方法区/永久代/元空间**：
  - 类信息（包括类的结构、方法数据、方法代码、构造函数、静态变量等）存储在方法区中。在JVM规范中，**方法区是一个逻辑部分**，具体实现依赖于JVM在HotSpot JVM中，这部分被称为**永久代**（PermGen）或**元空间（MetaSpace）**，具体取决于JVM的版本。
  - **Java8后放在本地内存,称为元空间**
- **堆（Heap）**：
  - 所有的Java**对象实例**以及**数组**都在堆内存中分配。这包括类的实例**（非静态）字段**。堆是JVM中最大的一块内存区域，是垃圾收集器管理的**主要区域**。
- **虚拟机栈（Stack）**：
  - 每个线程运行时都有一个调用栈，用于存储**局部变量（包括对堆中对象的引用）和部分方法调用信息**。当调用一个方法时，一个新的栈帧被创建并压入调用栈，该方法的返回时，栈帧被弹出。





**常见问题**



![image-20250313213314402](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313213314402.png)

##### **程序计数器(PC)**:

- **线程私有**,内部保存字节码的行号,用于记录正在执行**字节码指令的地址**

![image-20250312230749769](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312230749769.png)



##### 堆:

线程**共享区域**,所有的Java**对象实例以及**数组都在堆内存中分配,存放非静态字段,存在内存溢出风险,内存不够会抛出异常

- Java8 中包括  年轻代(Eden区)和老年代



​	<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312231922516.png" alt="image-20250312231922516" style="zoom:50%;" /><img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312231708404.png" alt="image-20250312231708404" style="zoom:50%;" />

**Java8** 后在堆中没有**方法区/永久代**,而是放在本地内存,称为元空间	**==永久代->元空间==**

- 相当于Java8做了优化,防止堆内存溢出 	**OutOfMemoryError**



##### **虚拟机栈:**

**线程私有**,每个线程运行时**所需要的内存**,先进后出,默认大小为1024k

每次方法调用所占用的内存称为**栈帧**,栈中存对象引用

- 栈帧过大会导致线程数过少,eg默认栈内存是1024k,机器总内存是512m,则最大线程数为512,增大栈帧,则线程数相应变少



<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250305220430436.png" alt="image-20250305220430436" style="zoom:70%;" />

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313213829078.png" alt="image-20250313213829078" style="zoom: 40%;" />

- 方法内的**局部变量**是否线程安全

  - 局部变量完全在方法作用范围内是线程安全的
  - 如果局部变量引用了对象,并且逃离的方法的作用范围,则需要考虑线程安全

  <img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313000141162.png" alt="image-20250313000141162" style="zoom:50%;" />



- 栈内存溢出

  - **栈帧过多**导致溢出,eg递归调用溢出,例如**StackOverflowError**

    (属于错误,错误通常不是被设计来被捕获或处理的，而是指示着需要对代码进行某些根本性的修正)

  - 栈内存过大(少见)



##### 对比堆和栈

- 堆内存主要存Java对象和数组,栈内存主要存**局部变量和方法调用** **(存储数据类型不一样)**
- 垃圾回收一般在堆区域,栈区域不会**(针对GC范围)**
- 栈区域是线程私有,堆区域是共享的**(针对线程关系)**



##### 方法区/元空间

Method Area同样是线程共享的区域,**Java8后称为元空间,存放在本地内存(避免OOM)**



<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313002232774.png" alt="image-20250313002232774" style="zoom:50%;" />

主要存储**类的信息(类的数量越大,这个占用就越大),运行时常量池,默认没有大小限制**

虚拟机启动时创建,关闭时才释放,无法满足请求会抛出 **OutOfMemoryError:Metaspace**

构造函数字段在元空间





#### 类装载

1.**加载**

​	查找和导入class文件

- 由类加载器负责根据一个类的**全限定名**来读取此类的**二进制字节流**到JVM内部，

- 解析类的二进制数据流为方法区内的数据结构(Java类模型)

- 创建class类的实例,表示该类型,class对象放在堆中.作为方法区这个类的各种数据的**访问入口**

​		<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313211510217.png" alt="image-20250313211510217" style="zoom:67%;" />





2.**链接**：

在加载之后，类将经过链接过程。链接验证类中的字节码，为静态字段分配存储空间，并且可以解析这个类创建的对象所引用的其他类。

- 2.1**验证**
  验证加载类是否符合JVM规范

  - 格式检查
  - 符号引用验证
  
- 2.2**准备**
  
  为变量类分配内存并设置类变量初始值

  - static变量 分配空间在准备阶段完成(**默认值**),赋值在初始化阶段完成
  - static变量 是final的基本类型,以及字符串常量,值已确定,赋值在准备阶段完成
  - static变量 是final的引用类型,那么赋值也会在初始化阶段完成(第二点的特例)
  
- 2.3**解析**

  将常量池中的**符号引用转为直接引用**

  比如:方法中调用了其他方法,方法名可以理解为符号引用,直接引用就是使用指针直接指向方法

  解析需要静态绑定的内容。 // 所有不会被重写的方法和域都会被静态绑定

3.**初始化（先父后子）**

​	对类的静态变量,**静态代码块**执行初始化操作

​	父类未初始化就先初始化父类,若同时包含多个静态变量和静态代码块,则按照自上而下的顺序执行

- ==访问静态变量之前会执行静态代码块(自上而下执行),如果父类的未初始化就会先执行静态代码块==

- ==子类访问父类的静态变量,只会触发父类的初始化==



4.使用

new关键字创建对象实例

调用静态类成员变量



5.卸载



<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313205221334.png" alt="image-20250313205221334" style="zoom:40%;" />







#### 双亲委派模型

针对的是 Java 虚拟机中三个类加载器的，这三个类加载器分别是：
启动类加载器（Bootstrap ClassLoader）
扩展类加载器（Extension ClassLoader）
应用程序类加载器（Application ClassLoader）

自定义的类加载器





#### 对象什么时候可以被GC回收

主要是回收堆中的对象,**一个或多个对象没有任何的引用指向它了**,那么这个对象就是垃圾

两种计数方法:

- **引用计数法**

​	根据引用次数,对象头会递增引用次数,次数为0就代表对象可被回收

​	问题:**对象可能互相循环引用,会导致内存泄漏**

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313213919108.png" alt="image-20250313213919108" style="zoom:40%;" />

- **可达性分析算法**

​	GC Roots出发

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313214126923.png" alt="image-20250313214126923" style="zoom:40%;" />

#### 哪些对象可作为GC Root

- 虚拟机栈(栈帧中的本地变量表)中的引用的对象								
- 方法区类静态属性引用的对象
- 方法区中常量引用的对象

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313214433270.png" alt="image-20250313214433270" style="zoom:50%;" />





#### 常见的垃圾回收算法

- **标记清除算法**

​	标记+清除

1.可达性分析算法标记垃圾

2.回收标记的垃圾

优点:标记,清除快

缺点:**碎片化较为严重,内存不连贯**



- **标记整理算法**

相比标记清除,还做了整理,性能受到了一定的影响

场景:**老年代使用多**



- **复制算法**

将内存分为两块,存活的对象整理放在另一块区域

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313215408347.png" alt="image-20250313215408347" style="zoom:40%;" />

优点:效率高,无内存碎片

缺点:只能使用一半,内存使用率低

场景:**年轻代使用多**



#### JVM的分代回收

young区占1/3堆区域,old占2/3堆区域

young区中分为伊甸区和幸存者区 Eden:from:to = 8:1:1

15次gc后从伊甸区调入幸存者区,再入老年代



#### GC垃圾回收器

##### JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old

##### Serial 收集器

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**



##### ParNew 收集器

ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**





##### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

##### Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。



年限长,整套解决方案,电池云平台大数据分析,电池的寿命分析



电动自行车,充电

换电一整套系统,

80个人 软件20个人 硬件20人

前后 产品经理

后端	6

技术储干,技术栈认识,功底扎实

两轮面试



##### CMS(Concurrent Mark Sweep)收集器

特点

1. 针对老年代
2. **标记-清除算法** (不进行压缩操作，产生内存碎片)；
3. 收集过程中不需要暂停用户线程
4. 以获取最短回收停顿时间为目标

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的

- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

CMS 垃圾回收器在JDK 1.5 时引入，JDK9 被标记弃用 

“**浮动垃圾**”







##### G1收集器

建立**可预测的停顿时间模型**

- JDK9之后默认使用G1
- 每个区域都可以充当eden,survivor,old,humongous
- 采用复制算法
- 三个阶段:**新生代回收(stw),并发标记(重新标记stw),混合收集**
- 响应时间和吞吐量兼顾
- 并发失败,会触发Full GC

**新生代回收(stw)**:首先将eden区垃圾回收,放入survivor区(需要stw),再过一段时间eden区间不够用就用复制算法将eden,survivor区复制到新的survivor,较老的对象晋升到老年代

**并发标记**:老年代内存超过阈值默认45%时,触发**并发标记,无需暂停用户线程**

**混合收集**(**可预测的停顿**):根据暂停时间优先回收价值高的区域,eden,survivor,old都参与

标记整理



##### ZGC

概述
**在JDK 11当中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。它是一款低停顿高并发的收集器。**



**基于指针着色的内存管理****无需对象头修改**：**直接在指针中管理对象状态**，减少内存开销

**并发重定位**：对象迁移时，通过指针的元数据快速定位新地址，无需全局暂停。





ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。

**ZGC在标记、转移和重定位阶段几乎都是并发的**，这是ZGC实现停顿时间小于10ms目标的最关键原因。

![image-20250318150518757](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250318150518757.png)