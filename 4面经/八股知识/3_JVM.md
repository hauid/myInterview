## JVM

javap -v [类名]  查看字节码文件的信息





#### 编译器

​	Java 里的编译器可以分为**前端编译器和运行期编译器**，前端编译器是指将 .java 编译成 .class 的过程，而运行期编译器则是指将 .class 字节码转变成**机器码**的过程，而运行期编译器的英文为 Just In Time Compiler，所以又能简称为 JIT 编译器





#### 类和对象在内存中的存储

- **方法区/永久代/元空间**：
  - 类信息（包括类的结构、方法数据、方法代码、构造函数、静态变量等）存储在方法区中。在JVM规范中，**方法区是一个逻辑部分**，具体实现依赖于JVM在HotSpot JVM中，这部分被称为**永久代**（PermGen）或**元空间（MetaSpace）**，具体取决于JVM的版本。
  - **Java8后放在本地内存,称为元空间**
- **堆（Heap）**：
  - 所有的Java**对象实例**以及**数组**都在堆内存中分配。这包括类的实例**（非静态）字段**。堆是JVM中最大的一块内存区域，是垃圾收集器管理的**主要区域**。
- **虚拟机栈（Stack）**：
  - 每个线程运行时都有一个调用栈，用于存储**局部变量（包括对堆中对象的引用）和部分方法调用信息**。当调用一个方法时，一个新的栈帧被创建并压入调用栈，该方法的返回时，栈帧被弹出。



##### **程序计数器(PC)**:

- **线程私有**,内部保存字节码的行号,用于记录正在执行**字节码指令的地址**

![image-20250312230749769](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312230749769.png)



##### 堆:

线程**共享区域**,所有的Java**对象实例以及**数组都在堆内存中分配,存放非静态字段,存在内存溢出风险,内存不够会抛出异常

- Java8 中包括 年轻代(Eden区)和老年代



​	<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312231922516.png" alt="image-20250312231922516" style="zoom:50%;" /><img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312231708404.png" alt="image-20250312231708404" style="zoom:50%;" />

**Java8** 后在堆中没有**方法区/永久代**,而是放在本地内存,称为元空间	**==永久代->元空间==**

- 相当于Java8做了优化,防止堆内存溢出 	**OutOfMemoryError**



##### **虚拟机栈:**

**线程私有**,每个线程运行时**所需要的内存**,先进后出,默认大小为1024k

每次方法调用所占用的内存称为**栈帧**

- 栈帧过大会导致线程数过少,eg默认栈内存是1024k,机器总内存是512m,则最大线程数为512,增大栈帧,则线程数相应变少



<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250305220430436.png" alt="image-20250305220430436" style="zoom:70%;" />

- 方法内的**局部变量**是否线程安全

  - 局部变量完全在方法作用范围内是线程安全的
  - 如果局部变量引用了对象,并且逃离的方法的作用范围,则需要考虑线程安全

  <img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313000141162.png" alt="image-20250313000141162" style="zoom:50%;" />



- 栈内存溢出

  - **栈帧过多**导致溢出,eg递归调用溢出,例如**StackOverflowError**

    (属于错误,错误通常不是被设计来被捕获或处理的，而是指示着需要对代码进行某些根本性的修正)

  - 栈内存过大(少见)



##### 对比堆和栈

- 堆内存主要存Java对象和数组,栈内存主要存局部变量和方法调用**(存储数据)**
- 垃圾回收一般在堆区域,栈区域不会**(针对GC范围)**
- 栈区域是线程私有,堆区域是共享的**(针对线程关系)**



##### 方法区/元空间

Method Area同样是线程共享的区域,**Java8后称为元空间,存放在本地内存(避免OOM)**



<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313002232774.png" alt="image-20250313002232774" style="zoom:50%;" />

主要存储**类的信息(类的数量越大,这个占用就越大),运行时常量池,默认没有大小限制**

虚拟机启动时创建,关闭时才释放,无法满足请求会抛出 **OutOfMemoryError:Metaspace**





#### 类加载和初始化

1.**加载**
由类加载器负责根据一个类的**全限定名**来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例

2.**链接**：

在加载之后，类将经过链接过程。链接验证类中的字节码，为静态字段分配存储空间，并且可以解析这个类创建的对象所引用的其他类。

- 2.1**验证**
  验证是否符合class文件规范

- 2.2**准备**
  为类中的**所有静态变量分配内存空间**，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）
  被**final修饰的static变量（常量）**，会直接赋值；

- 2.3**解析**
  将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。
  解析需要静态绑定的内容。 // 所有不会被重写的方法和域都会被静态绑定

3.**初始化（先父后子）**



#### 双亲委派模型

针对的是 Java 虚拟机中三个类加载器的，这三个类加载器分别是：
启动类加载器（Bootstrap ClassLoader）
扩展类加载器（Extension ClassLoader）
应用程序类加载器（Application ClassLoader）

自定义的类加载器



#### GC垃圾回收器

##### CMS

HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；



##### Serial Old收集器(标记-整理算法)

- Serial 新生代收集器采用的是复制算法。
- Serial Old 老年代采用的是标记 - 整理算法。

##### CMS(Concurrent Mark Sweep)收集器

特点

1. 针对老年代
2. **标记-清除算法** (不进行压缩操作，产生内存碎片)；
3. **并发**
4. 多线程
5. 收集过程中不需要暂停用户线程
6. 以获取最短回收停顿时间为目标

“**浮动垃圾**”



##### G1收集器

可并行，可并发

**能充分利用多CPU、多核环境下的硬件优势**



##### ZGC

概述
**在JDK 11当中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。它是一款低停顿高并发的收集器。**

**ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。**那么其他阶段是怎么做到可以并发执行的呢？