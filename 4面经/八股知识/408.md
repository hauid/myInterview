

### 计组

#### 1.上下文(Context)的概念,切换步骤

**一个线程运行时所拥有的空间:上下文通常包括以下信息**
**程序计数器（PC）**：指示当前线程执行到的指令位置。
**寄存器**：包括通用寄存器、状态寄存器等，保存线程的临时数据。
**方法栈空间**: 内存的一部分，容量远大于寄存器，可以存储大量的数据
**栈指针**：指向线程的栈空间，用于保存函数调用和局部变量。
**其他状态信息**：如浮点寄存器、**内存管理单元（MMU）**的状态等。

共享进程的**堆,字符串常量池**

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250305220430436.png" alt="image-20250305220430436" style="zoom:80%;" />



**线程执行上下文切换的步骤**
**保存**当前线程的上下文：操作系统将**当前线程的寄存器、程序计数器**等状态保存到内存中。
**加载**下一个线程的上下文：操作系统从**内存中恢复下一个线程的寄存器、程序计数器**等状态。
**切换**执行：CPU 开始执行下一个线程的指令

上下文切换需要**保存和恢复大量的状态信息**，因此会带来一定的性能开销。频繁的上下文切换可能会降低系统的整体性能。**(协程的优势)**



### 操作系统

#### go语言的协程

协程是一种**用户级的轻量级线程**。协程拥有自己的**寄存器上下文和栈(见计组介绍)**
协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过**分时复用**的方式运行多个协程，而且**协程的切换在用户态**完成，**切换的代价比线程从用户态到内核态的代价小很多**



**对比线程协程**

- 调度方式:线程由OS调度,协程由用户态调度

- 控制管理:线程是抢占式的,协程是协作式的,切换由程序自身控制
- 资源消耗:线程创建和销毁成本都很大,涉及系统调用,切换速度慢;协程拥有自己的寄存器上下文和栈,协程成本小,切换速度快
- 使用场景:线程适合和OS紧密交互的场景,协程适合异步转同步,IO密集型,异步回调,事件驱动型编程





#### 进程间的7种通信

**方式如下：**

**管道**pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
**命名管道FIFO**：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
**消息队列MessageQueue**：消息队列是由**消息的链表，存放在内核中并由消息队列标识符标识**。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及**缓冲区大小受限**等缺点。
**共享存储SharedMemory**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
**信号量Semaphore**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为**进程间以及同一进程内不同线程之间的同步手段。**
**套接字Socket**：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
**信号 ( sinal )** ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。





tong yi地址





#### 虚拟内存

​	内存管理的一种技术,逻辑抽象的内存空间,**本质是局部性原理**

​	虚拟内存容量可以比实际物理内存大(存在置换算法),OS可以通过磁盘来扩展虚拟内存

- 由于局部性原理

  对于OS只需要加载进程当前正在使用的部分数据和指令到内存

​	进程访问的是虚拟内存，通过映射再去找到实际的物理内存；所以需要一种映射方式，一般都是页表形式，那么对于**进程来说**，感知到的虚拟内存空间就会比实际物理内存大，因为对于**不常用的内存可以被换到磁盘中，需要时再从磁盘换入**；

- 为每个进程抽象一致且私有的虚拟内存空间,**实现内存隔离**

  简化内存管理虚拟内存也使得进程的内存相互隔离，

- 提高了内存访问的安全性；

  页表提供标记页属性的比特位(控制读写权限)

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313231404572.png" alt="image-20250313231404572" style="zoom:80%;" />

![image-20250313231011718](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250313231011718.png)



**MMU(内存管理单元)**将虚拟地址翻译为物理地址有三种方式:

**分段**:段之间容易有外部碎片

**分页**:逻辑地址=页号+页内偏移量	

页号 = 逻辑地址/页面长度

页内偏移量 = 逻辑地址%页面长度

由页号查页表得到块号(内存块号),由内存块号和页内偏移量得到具体的物理地址

**段页式**



**请求分页管理**:

请求页表:(页号) + 内存块号 + 状态位(是否已调入内存) + 访问字段 + 修改位(修改过才写回外存) +....



**TLB**:虚拟地址部分会缓存在块表中,命中TLB只需一次内存访问,未命中则需要通过页表,两次内存访问



### 计网



#### 设备

看一个设备工作在哪一层，需要看它的主要实现功能使用的是哪一层协议头信息。

- 网桥：工作在**数据链路层**，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。



- 交换机：工作在**数据链路层**，原理等同于多端口网桥。作用是连接数个相同网段的不同主机，减少网内冲突，隔离冲突域。利用存储转发和过滤技术来从物理上分割网段。



- 路由器：工作在**网络层**，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。



- 网关：对**高层协议（包括传输层及更高层次）**进行转换的网间连接器。允许使用不兼容的协议，比如SPX/IPX和TCP/IP的系统和网络互连。因为**协议转换是网关**最重要的功能，所以答案是工作在**传输层及以上层次**。



- 网卡：在物理层上**网卡**主要是完成物理接口的连接,电信号的传送以及将数据分解为适当大小的数据包之后向网络上发送的功能. 数据链路层功能包括链路建立和拆除，帧定界同步顺序差错控制这些。大多认为主要工作在物理层。



当然，很多设备在概念上变得越来越模糊。如**桥接路由器是网桥和路由器的组合，允许多重连接，对某一种协议具有专用路由选择方法，对其他协议只充当网桥的作用。**

**网桥，路由器，交换机和网关可以安装在同一幢楼或校园区，也可以使用远程连接。**





**HTTP/2使用HPACK压缩算法压缩请求和响应的头部信息，减少了传输的数据量。**









#### Http协议

@ResponseBody 是 Spring 中的一种注解，通常用于将方法的返回值直接写入 HTTP 响应体，而不是通过视图解析器解析为视图（如 JSP 或 HTML).
@RestController = @Controller + @ResponseBody,表示该控制器返回 JSON 数据而不是视图。适用于前后端分离或REST API 开发。

请求协议：浏览器将数据以请求格式发送到服务器。包括：请求行(**常被视为属于请求头**)、请求头 、请求体
请求行：HTTP请求中的第一行数据。由：**请求方式、资源路径、协议/版本**组成（之间使用**空格**分隔)
请求头：第二行开始,格式为key: value形式
请求体 ：存储请求参数

GET请求:请求参数在请求行中，故**不需要设置请求体**
POST请求 :请求参数在请求体中,需要**多参数**(传递对象则使用POST请求)

Web服务器（Tomcat）对**HTTP协议**的请求数据进行解析，并进行了封装(**HttpServletRequest**)，并在调用Controller方法的时候传递给了该方法。



**1)响应行**(**常被视为属于响应头**)：响应数据的第一行,响应行由**协议及版本,响应状态码,状态码描述** 例如：HTTP/1.1 200 OK
**2)响应头**：响应数据的第二行开始。格式为key：value形式 例如：
Content-Type: application/json
Content-Length: 1234
**3)响应体**： 响应数据的最后一部分,存储响应的数据.

Web服务器对HTTP协议的响应数据进行了封装(HttpServletResponse)，并在调用Controller方法的时候传递给了该方法
1xx	响应中 --- 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略
2xx	成功 --- 表示请求已经被成功接收，处理已完成
3xx	重定向 --- 重定向到其它地方，让客户端再发起一个请求以完成整个处理
4xx	客户端错误 --- 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等
5xx	服务器端错误 --- 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等

- **200 ok   客户端请求成功**
- 404 Not Found  请求资源不存在
- **500 Internal Server Error  服务端发生不可预期的错误**





#### TCP,UDP

**TCP（传输控制协议）和UDP（用户数据报协议）**是计算机网络中传输层的两个主要协议，它们各自具有不同的特点和适用场景。以下是TCP和UDP之间的主要区别：

- 连接特性：
  TCP是**面向连接**的协议。在传输数据之前，需要通过**三次握手**来建立连接，并在数据传输完成后通过**四次挥手**来释放连接。这种连接机制确保了数据传输的可靠性和顺序性。
  UDP则是**无连接**的协议。发送数据前不需要建立连接，直接发送数据包，这使得UDP在传输数据时更加灵活和高效。
- 可靠性：
  TCP提供可靠的数据传输服务。它使用**校验和、重传控制、序号标识、滑动窗口和确认应答**等机制来确保数据的无差错、不丢失、不重复且按序到达。
  UDP则提供尽最大努力交付的服务，不保证数据的可靠传输。在数据传输过程中，如果发生丢包或乱序，UDP**不会进行重传或顺序控制**。
- 效率与实时性：
  UDP具有较好的实时性和较高的工作效率，因为它不需要建立连接和进行复杂的控制操作。这使得**UDP适用于对高速传输和实时性有较高要求的通信或广播通信，如语音、视频、直播等。**
  TCP虽然提供了可靠的数据传输，但由于其复杂的控制机制，相对UDP而言效率较低。
- 通信模式：
  TCP连接只能是**点对点**的，即一条TCP连接只能连接两个端点。
  UDP则支持**一对一、一对多、多对一和多对多**的交互通信模式，这使得UDP在广播和多播等场景中更具优势。
- 首部开销：
  TCP的首部较大，通常为**20**字节，这增加了每个数据包的开销。
  UDP的首部较小，只有**8**字节，减少了数据包的开销，提高了传输效率。

#### 三握四挥

第一次握手：
客户端将TCP报文标志位SYN置为1，**随机**产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。

第二次握手：
服务器端收到数据包后由标志位**SYN=1**知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。

第三次握手：
客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。
第二次分手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。
第三次分手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。
第四次分手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。



#### 云服务

那么把静态资源全部交给云服务商的 CDN 来承载，还可以再获得 90% 的 CPU 节省。同时，CDN 的流量费还比云主机的流量费更便宜

CDN通过管理**TCP连接来优化数据的传输。例如，CDN可以使用持久连接和TCP预连接技术来减少连接建立的时间**

#### CDN域名与API域名

CDN 域名和 API 域名在网络架构中承担不同的角色，主要区别如下：

---

##### **1. 用途不同**
- **CDN 域名**  
  - 主要用于加速**静态资源**的分发（如图片、视频、CSS/JS 文件等）。  
  - 通过全球分布的边缘服务器缓存内容，使用户就近获取资源，降低延迟。  
  - **示例**：`static.example.com` 或 `cdn.example.com`。

- **API 域名**  
  - 用于处理**动态请求**（如用户登录、数据提交、实时查询等）。  
  - 直接访问后端服务器或微服务，执行业务逻辑和数据库操作。  
  - **示例**：`api.example.com` 或 `service.example.com`。

---

##### **2. 性能优化方向**
- **CDN 域名**  
  - 优化目标：**传输速度**和**带宽成本**。  
  - 技术手段：缓存、压缩、HTTP/2 或 QUIC 协议。  

- **API 域名**  
  - 优化目标：**响应时间**和**并发处理能力**。  
  - 技术手段：负载均衡、数据库索引优化、异步处理。

---

##### **3. 缓存策略**
- **CDN 域名**  
  - 强依赖缓存（Cache-Control 头设置较长的 TTL）。  
  - 例如：图片缓存 7 天，JS/CSS 缓存 1 年。  

- **API 域名**  
  - 通常禁用缓存或设置极短 TTL（如 `Cache-Control: no-cache`）。  
  - 动态数据（如用户信息）需实时从服务器获取，避免脏数据。

---

##### **4. 安全性要求**
- **CDN 域名**  
  - 主要防御 **DDoS 攻击** 和 **盗链**（通过 Referer 校验、Token 鉴权）。  
  - 可通过 CDN 提供商的防火墙过滤恶意流量。  

- **API 域名**  
  - 需严格保护**业务逻辑**和**敏感数据**。  
  - 常见措施：HTTPS 加密、OAuth/JWT 认证、速率限制（Rate Limiting）、输入验证。

---

##### **5. 配置差异**
| **配置项**     | **CDN 域名**              | **API 域名**            |
| -------------- | ------------------------- | ----------------------- |
| **DNS 解析**   | CNAME 指向 CDN 服务商     | A 记录直接指向服务器 IP |
| **SSL 证书**   | 通常由 CDN 服务商统一管理 | 需自行部署和管理        |
| **请求头处理** | 可能隐藏源服务器信息      | 暴露业务相关的自定义头  |

---

##### **典型错误案例**
- **误将 API 请求发送到 CDN**  
  - 后果：动态请求被缓存，返回过期数据或导致逻辑错误。  
  - 解决：通过 URL 路径区分（如 `/static/` 走 CDN，`/api/` 直连服务器）。

- **CDN 缓存敏感内容**  
  - 后果：用户隐私数据泄露（如缓存了 `/api/user/123` 的响应）。  
  - 解决：设置 `Cache-Control: private, no-store`。

---

##### **总结**
- **CDN 域名**：专注**静态资源加速**，依赖缓存，优化传输效率。  
- **API 域名**：专注**动态业务处理**，强调实时性和安全性。  
- **核心区别**：CDN 是“内容搬运工”，API 是“业务处理器”。实际应用中通常二者分离，避免相互干扰。



#### **从计算机网络层次分析域名解析**

在计算机网络的分层模型中，域名（如 `www.baidu.com`）属于 **应用层（Application Layer）**，具体对应以下两种主流模型：

---

##### **1. OSI 七层模型**
- **应用层（第7层）**：  
  域名（DNS）是应用层协议的一部分，用于将人类可读的域名（如 `www.baidu.com`）解析为机器可识别的 IP 地址（如 `14.215.177.39`）。  
  - **DNS 的作用**：提供域名与 IP 地址的映射服务，属于典型的应用层功能。  
  - **应用场景**：用户通过浏览器访问网站时，浏览器会通过 DNS 协议向 DNS 服务器查询域名对应的 IP 地址。

---

##### **2. TCP/IP 四层模型**
- **应用层**（对应 OSI 的会话层、表示层、应用层）：  
  域名解析（DNS）和 HTTP/HTTPS 等协议均属于这一层。  
  - **关键特点**：直接面向用户或应用程序提供服务（如网页访问、文件传输）。

---

##### **为什么域名属于应用层？**
1. **功能定位**：  
   域名是为了方便人类记忆而设计的抽象标识符，与应用逻辑（如访问网站、发送邮件）直接相关，而非底层数据传输。

2. **协议依赖**：  
   DNS 协议运行在应用层，默认使用 **UDP 53 端口**（或 TCP 53 端口），依赖传输层（Transport Layer）提供的数据传输服务。

3. **数据封装关系**：  
   当用户访问 `www.baidu.com` 时，数据包的封装流程为：  
   **应用层（DNS 请求）→ 传输层（UDP/TCP）→ 网络层（IP）→ 数据链路层（以太网）→ 物理层（光信号/电信号）**。

---

##### **常见误区**
- **域名不属于网络层（IP 层）**：  
  虽然域名最终对应 IP 地址（网络层），但域名本身是应用层的逻辑标识符，IP 地址是网络层用于路由的物理地址。

- **域名解析依赖多层级联**：  
  DNS 解析过程中可能涉及本地缓存、递归查询、权威服务器等，但这些流程均在应用层完成。

---

##### **总结**
- **域名（如 `www.baidu.com`）**：应用层（提供面向用户的服务）。  
- **IP 地址（如 `14.215.177.39`）**：网络层（负责路由和寻址）。  
- **DNS 协议**：应用层协议，用于将域名转换为 IP 地址。