#### 网络为什么要分层

**职责解耦**,底层细节要对上层屏蔽,只对上层提供功能



#### HTTP

@ResponseBody 是 Spring 中的一种注解，通常用于将方法的返回值直接写入 HTTP 响应体，而不是通过视图解析器解析为视图（如 JSP 或 HTML).
@RestController = @Controller + @ResponseBody,表示该控制器返回 JSON 数据而不是视图。适用于前后端分离或REST API 开发。

请求协议：浏览器将数据以请求格式发送到服务器。包括：请求行、请求头 、请求体
请求行：HTTP请求中的第一行数据。由：请求方式、资源路径、协议/版本组成（之间使用空格分隔
请求头：第二行开始,格式为key: value形式
请求体 ：存储请求参数



GET请求的请求参数在请求行中，故不需要设置请求体
POSTt请求 请求参数在请求体中
Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装(HttpServletRequest)，并在调用Controller方法的时候传递给了该方法。

**1)响应行**：响应数据的第一行,响应行由协议及版本,响应状态码,状态码描述 例如：HTTP/1.1 200 OK
**2)响应头**：响应数据的第二行开始。格式为key：value形式 例如：
Content-Type: application/json
Content-Length: 1234
**3)响应体**： 响应数据的最后一部分,存储响应的数据.

Web服务器对HTTP协议的响应数据进行了封装(HttpServletResponse)，并在调用Controller方法的时候传递给了该方法
**1xx**	响应中 --- 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略
**2xx**	成功 --- 表示请求已经被成功接收，处理已完成
**3xx**	重定向 --- 重定向到其它地方，让客户端再发起一个请求以完成整个处理
**4xx**	客户端错误 --- 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等
**5xx**	服务器端错误 --- 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等

- **200 ok   客户端请求成功**
- **404 Not Found  请求资源不存在**
- **500 Internal Server Error  服务端发生不可预期的错误**







#### TCP/IP模型

数据链路层:01bit传输,解决**物理层面寻址**问题

网络接口层:TCP/IP模型的第四层，它负责管理网络硬件设备和物理媒介之间的通信。网络接口层包括各种物理层和数据链路层协议，如以太网、Wi-Fi、蓝牙等。它提供了传输数据的物理媒介，同时为网络层提供一条准确无误的线路。

网络层:对物理地址进一步**抽象和聚合**,每个计算机都有自己的MAC,MAC判断本身低效,

网络层聚合处理提供数据传输的效率

传输层:定位到具体的端口号,进行不同主机**进程通信**

应用层:具体的**数据传输格式和协议**,http协议,高性能GRPC协议



#### TCP



<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312113555686.png" alt="image-20250312113555686" style="zoom: 80%;" />

#### **三大特性:面向连接的、可靠的、基于字节流**



**序列号(seq)**：在建立连接时由计算机生成的**随机数**作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

**确认应答号(ack)**：指下一次「期望」收到的数据的序列号**(等于对方发过来的seq+1)**，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

**控制位：**

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。



![image-20250318151729019](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250318151729019.png)

#### **三次握手建立连接							**

#### **最主要原因就是防止「历史连接」初始化了连接。**

- **主要原因:**在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。
- 客户端发送的 `SYN` 报文在网络中阻塞了，重复发送多次 `SYN` 报文，那么服务端在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。



#### **不用四次握手**

- 三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。



<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250312115449680.png" alt="image-20250312115449680" style="zoom: 67%;" />

#### 为什么挥手需要四次？

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示**客户端不再发送数据了但是还能接收数据**。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而**服务端可能还有数据需要处理和发送**，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。



`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。



​	TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

​	比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 `FIN` 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

​	可以看到 **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。