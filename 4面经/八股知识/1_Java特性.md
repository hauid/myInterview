## JavaSE

#### 数据类型

八种基本类型。
六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。  
6:byte 1 short 2 int 4  long 8 float 4 double 8
1:boolean 2
1:char    1bit
引用数据类型：**类（Class）、接口（Interface）、数组（Array）**,除八大基本类型之外的所有数据类型，都为引用数据类型.  

#### 变量分类

变量分为

##### **1.局部变量**

**局部变量（Local Variables）：**局部变量是在方法、构造函数或块内部声明的变量，它们在声明的方法、构造函数或块执行结束后被销毁，局部变量在声明时需要初始化，否则会导致编译错误。



##### **2.成员变量**（member variable）

**2.1实例(无static)变量**

​	在某个方法外部，类内部定义的变量，从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型默认的初始值。部分变量的默认初始值如下表所示

```java
public class TestVariable{
	int a;//成员变量，会自动初始化
	public static void main(String[] args){
		.....
		} 
}

```

##### **2.2静态(static)变量** 

​	静态变量使用static定义，从属于类，声明周期伴随类始终，从类加载时产生，类卸载时结束。如果不进行初始化，与成员变量一样，会自行初始化成该类型的默认初始值。

通过**类名.静态变量**就可以访问了，不需要创建类的实例





#### 匿名内部类

定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，**如果某个局部类你只需要用一次，那么你就可以使用匿名内部类**







#### String 类不可变

其设计和JVM内部的处理共同保证

本身设计

1. 保存字符串的数组被 `final` 修饰且为**私有**的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. `String` 类本身被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

JVM设计

​	1. 





#### 字符串常量池的作用

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对**字符串（String 类）**专门开辟的一块区域，主要目的是为了避免字符串的重复创建。





![image-20250309221936168](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250309221936168.png)







#### String s1 = new String("abc");这句话创建了几个字符串对象？

会创建 1 或 2 个字符串对象。

1. 字符串常量池中不存在 "abc"：会创建 2 个 字符串对象。一个在字符串常量池中，由 `ldc` 指令触发创建。一个在堆中，由 `new String()` 创建，并使用常量池中的 "abc" 进行初始化。
2. 字符串常量池中已存在 "abc"：会创建 1 个 字符串对象。该对象在堆中,由 `new String()` 创建，并使用常量池中的 "abc" 进行初始化。



**总结`new String("abc")` 表达式：**

- 不论常量池中是否存在“abc”，`new String("abc")` 总是在堆上创建一个新的字符串对象。
- 这个新创建的字符串对象会复制一份常量池中“abc”的值。这意味着，堆中的这个新对象拥有与常量池中“abc”相同的字符序列，但它们是两个完全独立的对象实例。



保存字符串。**String 类本质是一个 final修饰的 对象**，由引用指向存储字符串对象的地址。引用虽然可变，但内存数据不能被更改。


String类常用api
length()	获取字符串的长度
equals(String s)	判断两个字符串内容是否相同
equalsIgnoreCase(String s)	不区分大小写判断两个字符串内容是否相同
charAt(int index)	返回下标所在的cha值(字符)
indexOf(String s)	返回字串第一次出现的位置，没出现则返回-1
lastIndexOf(String s)	返回字串最后一次出现的位置，没出现返回-1
starstWith(String prefix)	判断字符串是否以prefix为前缀开头
endsWith(String suffix)	判断字符串是否以suffix为后缀结尾
toLowerCase()	返回字符串的小写形式
toUpperCase()	返回字符串的大写形式
substring(int startindex,int endindex)	返回从startindex开始到endindex结束的字串
contains(String s)	判断是否包含字串s
concat(String s)	字符串拼接，相当于+
replaceAll(String oldSrt,String newSrt)	替换原有字符串中的字串为目标字串
split(String split)	以指定字符串分割后返回字符串数组
tocharArray()	将此字符串转换为一个新的字符数组
tirm()	返回字符串两边消除空格后的字符串
isEmpty()	判断字符串是否为空



#### 什么是序列化?什么是反序列化?

如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

简单来说：

- **序列化**：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式
- **反序列化**：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程

------

序列化和反序列化**常见应用场景**：

- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。

------







#### 泛型

可使用 A-Z 之间的任何一个字母，常用：
T (type)： 表示具体的一个 java 类型
K V (key value)： 分别代表 java 键值中的 Key Value
E (element)： 代表 java 集合框架元素
？：表示不确定的 java 类



#### 修饰符

**static变量(类变量)**：它意味着这个成员属于类本身，所有的实例共享它。就像班级里的学校名称，所有学生都知道一样。
public class Student {
    String name; // 每个学生的姓名
    static String schoolName = "My School"; // 所有学生共享的学校名称

```java
public Student(String name) {
    this.name = name;
}

// 获取学校名称，所有学生都会使用同一个学校名称
public static void printSchoolName() {
    System.out.println(schoolName);
}
```

}

static 修饰的方法(类方法):**static 方法与类本身相关**，而与类的实例（即对象）无关
属于类本身：static方法是属于类的，而不是某个对象的。
可以直接通过类调用：可以通过类名直接调用 static 方法，像 Classroom.startClass()。
不需要实例化对象：你不需要创建对象就可以调用 static 方法，这使得 static 方法适用于那些与具体对象状态无关的功能。
不能访问实例成员：static方法不能直接访问类的实例变量或实例方法（非 static 成员），因为它没有类的实例（对象）



#### Static修饰类	- >	静态内部类

静态内部类可以**直接创建实例**，无需先创建外部类对象：

```java
public class Outer {
    // 静态内部类
    public static class StaticInner {
        void print() {
            System.out.println("我是静态内部类");
        }
    }

    // 非静态内部类
    public class NonStaticInner {
        void print() {
            System.out.println("我是非静态内部类");
        }
    }
}

// 使用静态内部类：无需 Outer 实例
Outer.StaticInner staticInner = new Outer.StaticInner();
staticInner.print();

// 使用非静态内部类：必须通过 Outer 实例创建
Outer outer = new Outer();
Outer.NonStaticInner nonStaticInner = outer.new NonStaticInner();
nonStaticInner.print();
```

三个作用

- **独立于外部类实例**,静态内部类可以直接创建实例，无需先创建外部类对象
- 静态内部类可以直接访问外部类的静态成员，但无法直接访问非静态成员：
- 非静态内部类会**隐式持有外部类的引用**，可能导致内存泄漏（如内部类被长生命周期对象引用时）,静态内部类没有外部类引用，更安全

​		**隐式引用**：编译器会自动为非静态内部类添加一个指向外部类实例的 `final` 字段



#### 非静态内部类与静态内部类总结对比

| **特性**           | **非静态内部类**               | **静态内部类**                               |
| :----------------- | :----------------------------- | :------------------------------------------- |
| **隐式外部类引用** | 有（强引用）                   | 无                                           |
| **内存泄漏风险**   | 高（长生命周期场景）           | 低                                           |
| **访问外部类成员** | 直接访问                       | 需显式传递外部类实例（推荐弱引用）           |
| **适用场景**       | 短期使用、与外部类生命周期一致 | 需独立于外部类生命周期（如异步任务、监听器） |









#### **控制权限**

`private`是一个访问控制修饰符，用于变量、方法和构造器，表示它们只能在声明它们的**类内部被访问。**这意味着：

1. **封装性**：`private`修饰符是封装的一部分，它防止了**类的内部实现细节**被外部访问和修改。
2. **类内访问**：只有**同一个类**的方法可以访问其`private`成员，即使是该类的对象也不能从外部直接访问其`private`成员

private 方法只能在类内使用，外部无法访问,一般通过**公共方法间接访问 private 方法**
protected：在同一个包内或者通过继承访问子类中的 protected 成员。
默认访问修饰符：没有显式使用访问修饰符时，默认为包内访问，这意味着它只能在同一个包内访问
同一个包内的类：可以访问 public、默认、protected、private 成员（其中 private 只允许访问该类内部的成员）

跨包访问：
	public 成员：可以跨包访问。
	默认访问修饰符：只能在同一个包内访问，不能跨包访问。
	protected：可以在同一个包内访问，也可以通过继承关系在子类中访问。
	private：不能跨包访问，限制在本类内。

关键字:
final修饰的基本类型变量数据不能改变(通过反射操作还是可以使得其改变),修饰的引用类型变量地址不能改变,但指向的对象内容可以改变
用static final修饰的称为常量

#### List的方法

List接口包括Collection接口的所有方法。 
add() - 将元素添加到列表
get() - 有助于从列表中随机访问元素
remove() - 从列表中删除一个元素
clear() - 从列表中删除所有元素（比removeAll()效率更高）
size() - 返回列表的长度
toArray() - 将列表转换为数组
contains() -  如果列表包含指定的元素，则返回true



#### 异常和错误

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/293977480d4a208df31bb8ef4a3e33bb.png)





 //3

### 设计原则

**1开放封闭原则**：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。(主要的)

**2单一职责原则**：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。		(**接口功能隔离**)

**3依赖倒置原则**：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。									(**设计接口**)

**4接口隔离原则**：将不同功能定义在不同接口中实现接口隔离。																(**接口隔离**)

**5里氏替换原则**：任何基类可以出现的地方，子类一定可以出现。															(**子类替换**)

**6迪米特原则**：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。							**(分模块)**

**7合成复用原则**：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。		(**聚合**)



#### 设计模式

三大类：

**创建型模式**，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

**结构型模式**，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

**行为型模式**，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。



### 三大特性

//4

#### **封装**

（一）基本概念
封装(encapsulation)即信息隐蔽。它是指在确定系统的某一部分内容时，应考虑到其它部分的信息及联系都在这一部分的内部进行，外部各部分之间的信息联系应尽可能的少。

**指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体**。

（二）四种访问控制级别

public：对外公开，访问级别最高
protected：只对同一个包中的类或者子类公开
默认：只对同一个包中的类公开
private：不对外公开，只能在对象内部访问，访问级别最低

高内聚,低耦合原则





#### 继承

继承：让某个类型的对象获得另一个类型的对象的属性和方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。





#### 多态

好处:
右边对象解耦合,便于扩展和维护
定义方法时候使用**父类的形参可以接收一切子类对象,扩展性更强**

问题:
多态不能使用子类独有的功能



**多态的精髓**

- **编译看左边**（父类引用类型决定能调用哪些方法）
- **运行看右边**（实际执行子类重写后的方法）



#### 多态类型对比:重载(Overloading) 和重写(Overriding)

##### **核心结论**

- **重载**：同一个类中，**方法名相同，参数不同**（横向扩展）。
- **重写**：子类覆盖父类方法，**方法签名相同**（纵向替换）。

------

##### **对比表格**

| **特性**     | **重载 (Overloading)**                      | **重写 (Overriding)**                                        |
| :----------- | :------------------------------------------ | :----------------------------------------------------------- |
| **发生位置** | 同一个类中                                  | 父子类之间（子类重写父类方法）                               |
| **方法签名** | **必须不同**（参数类型、个数、顺序不同）    | **必须相同**（方法名、参数、返回类型）                       |
| **返回值**   | 可以不同                                    | 必须相同（或子类兼容父类返回值）                             |
| **访问权限** | 可以不同                                    | 子类方法不能比父类更严格（如父类`public`，子类不能`private`） |
| **多态性**   | 属于 **编译时多态**（编译时确定调哪个方法） | 属于 **运行时多态**（运行时根据对象类型决定）                |
| **核心目的** | **提供多种调用方式**（灵活点餐）            | **改变原有行为**（彻底改造方法）                             |

注意

- **对于重载不能仅改返回值**

  仅返回值不同不算重载，会编译报错。

```java
int 计算(int a) { ... }
double 计算(int a) { ... } // ❌ 编译错误！
```

可能当调用方法但不使用返回值时,如果允许仅通过返回值不同来重载方法，会导致编译器无法确定应该调用哪个方法，从而引发**歧义**。(Java编译时只能通过**方法名+参数类型**来确定调用哪个方法，**返回值类型无法作为依据**，因为它可能被忽略)

- **重写不能改参数类型**
  参数必须和父类一致，否则变成重载。

  ```java
  class 父类 {
      void 方法(int a) { ... }
  }
  class 子类 extends 父类 {
      void 方法(double a) { ... } // ❌ 这是重载，不是重写！
  }
  ```





#### **两种多态的本质区别**

1. 重载（Overloading）—— 编译时多态（**静态绑定**）

- **核心**：编译器在编译阶段根据**方法名+参数类型**确定调用哪个方法。
- **比喻**：像餐厅的**点餐系统**，根据你输入的选项（参数）自动分配对应厨师。
- **特点**：
  - 速度快（编译时确定）。
  - 灵活性低（无法根据运行时对象类型变化）。

2. 重写（Overriding）—— 运行时多态（**动态绑定**）

- **核心**：JVM在运行时根据**对象实际类型**确定调用哪个方法。
- **比喻**：像厨师**现场发挥**，同一道菜名（方法名），不同厨师（子类对象）做法不同。
- **特点**：
  - 速度稍慢（运行时动态查找）。
  - 灵活性强（支持扩展和替换）

#### **从底层理解两种多态**

**1. 重载的编译时决策**

Java编译器通过**方法签名（方法名+参数类型）**生成不同的调用指令。
例如：

```java
void test(int a) {}    // 编译后方法签名：test(I)V
void test(String s) {} // 编译后方法签名：test(Ljava/lang/String;)V
```

- **字节码中方法名完全不同**，因此能明确区分。

**2. 重写的运行时决策**

JVM通过**虚方法表（vtable）**动态查找实际对象的方法实现。(由JVM的**方法分派机制**实现)

- **父类引用**指向子类对象时，调用方法时会查子类的虚方法表。

- 例如：

  ```java
  Animal a = new Dog();
  a.sound(); // 运行时查找Dog类的sound()方法
  ```

#### **总结**

| **特性**     | **重载（编译时多态）** | **重写（运行时多态）** |
| :----------- | :--------------------- | :--------------------- |
| **区分依据** | 方法名 + 参数类型      | 对象实际类型           |
| **绑定时机** | 编译时                 | 运行时                 |
| **核心目的** | 提供多种调用方式       | 实现方法替换和扩展     |
| **灵活性**   | 低（依赖静态类型）     | 高（支持动态行为变化） |







#### 抽象类和接口的区别



------

#### **核心区别（表格对比）**

| **特性**     | **抽象类**                         | **接口**                                          |
| :----------- | :--------------------------------- | :------------------------------------------------ |
| **关键字**   | `abstract class`                   | `interface`                                       |
| **属性**     | 可以有成员变量（包括非final）      | 只能有 `public static final` 常量                 |
| **构造方法** | 可以有                             | 不能有                                            |
| **方法实现** | 可以包含**具体方法和抽象方法**     | Java 8前只能有抽象方法，之后支持默认方法/静态方法 |
| **继承关系** | 单继承（一个类只能继承一个抽象类） | 多实现（一个类可实现多个接口）                    |
| **设计目的** | **代码复用** + **定义结构模板**    | **定义行为契约** + **解耦**                       |
| **适用场景** | “是什么”（is-a关系）               | “能做什么”（has-a能力）                           |

##### **常见误区**

1. ❌ “接口不能有任何实现代码”
   Java 8+ 允许接口有 **默认方法** 和 **静态方法** 的实现。
2. ❌ “抽象类比接口更强大”
   两者设计目的不同，抽象类侧重 **代码复用**，接口侧重 **行为契约**。
3. ❌ “接口可以替代抽象类”
   如果需要共享代码或定义非public成员，必须用抽象类。



- 需要代码复用吗？→ **抽象类**
- 需要定义行为规范吗？→ **接口**





#### 异常

1.编译时异常
2.运行时异常
空指针异常,类型转换(ClassCast)异常,没找到类型异常(ClassNotFound),没有权限访问异常(IllegalAccess),线程池策略(RejectedExecutionException)

#### 反射

通过java语言中的**反射机制可以操作字节码文件**（可以**读和修改字节码文件**）
通过反射机制可以操作代码片段。（**class文件**）

使得**程序在运行时候反观和修改其内部结构**,**动态的操作类和对象**
获得class对象的方法

**1.静态引用获得class对象,不触发静态初始化**

**2.实例对象调用getClass方法**
**3.调用Class的forName方法**





### 涉及JVM的代码逻辑

​	无论是访问**静态方法还是非静态方法**，类都必须首先被加载和初始化。这是因为在任何方法（静态或非静态）被调用之前，Java虚拟机（JVM）需要有该类的一个有效定义在内存中

#### 类加载的代码逻辑

```java
public class TestClass {
    static {
        System.out.println("静态初始化块被执行。");
    }

    public static void staticMethod() {
        System.out.println("静态方法被调用。");
    }

    public TestClass() {
        System.out.println("构造方法被调用。");
    }
}

```

执行

```java
TestClass.staticMethod();

//输出
静态初始化块被执行。
静态方法被调用。
```



这是因为在首次访问类的静态方法之前，**类需要被加载和初始化**，包括执行静态初始化块。

如果之后你创建一个类的实例：

```java
new TestClass();

//输出
构造方法被调用。
```

请注意，静态初始化块不会再次执行，因为类已经在**之前被加载过了**。

### 

​	可以使用静态初始化块来执行类加载时的初始化任务。这种静态初始化块在类首次被加载到JVM时自动执行一次。