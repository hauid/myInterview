**消息队列**：消息队列是一种用于**处理大量并发请求的技术。通过将请求放入消息队列中，然后由专门的服务进程来处理这些请求，可以避免主线程被阻塞，从而提高系统的并发处理能力。**



​	在订单队列中设置**死信交换机和死信队列**，当订单消息的**延时时间**到达后，消息会自动转发到**死信队列**，从而触发关闭订单的操作。在死信队列中，我们可以监听消息，并执行关闭订单的逻辑。为了确保消息的可靠性，可以在**关闭订单操作前添加适当的幂等性措施**，这样即使**消息重复处理**，也不会对系统产生影响。



**为什么选择RocketMQ**

- 优化了Kafka来回拷贝问题,采用零拷贝技术

消息从消息队列的磁盘发送到消费者

消息发送过程:

​	<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250308192645459.png" alt="image-20250308192645459" style="zoom: 25%;" />			  

​	<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250308193226276.png" alt="image-20250308193226276" style="zoom:25%;" />

两次系统调用,**对应4次用户空间和内核空间的切换**

涉及4次数据拷贝 



**采用零拷贝技术**

- mmap:不需要拷贝到用户缓存区了,只涉及3次拷贝 **(这里的零拷贝:用户空间和内核空间不需要拷贝)**
- sendfile:不需要用户缓存区,不需要socket缓冲区,只涉及2次拷贝,**从内核缓冲区直接拷贝到网卡**
  - 对应一次系统调用,2次户空间和内核空间的切换 **(这里的零拷贝:不需要CPU参与的拷贝,DMA控制器实现)**



**对比**

RocketMQ:每秒10w量级的数据,采用的**mmap技术**			**(函数返回具体内容,应用层能获得消息内容)**

Kafka:17w量级的数据,采用的**sendfile技术**,更少的拷贝次数	**(函数返回成功发送了几个字节数,应用层不能获得消息内容)**



**取舍:**

大数据场景(极致性能):Kafka	

除此之外:**RocketMQ可以二次投递,将消费的失败的消息投入到死信队列**(12306**订单失败回调技术**)





​	
