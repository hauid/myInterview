

### 背景





<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250305193311288.png" alt="image-20250305193311288" style="zoom:80%;" />

#### 分类

幂等可能存在两种类型的问题：

- **接口幂等**：常说的接口防重复提交。
- **消息队列幂等**：如何保障**消息队列客户端对相同的消息仅消费一次**

##### 1. 接口防重复提交

如果**淘宝服务端**没有做相关防重复提交处理，那么就有可能生成多笔相同的订单。

如果做了幂等处理，除了第一次正常请求外，**第二次乃至更多次应该返回错误**，比如说提示语“重复提交失败”等；再或者返回“提交成功”，但是真正保存数据库的只有一次请求。具体使用哪一种需要看程序设计以及产品逻辑。

##### 2. 消息队列消费幂等

通常情况下，我们认为消息中间件是一个**可靠的组件**。这里的可靠性指的是，只要消息被成功投递到了消息中间件，它就不会丢失，至少能够**被消费者成功消费一次**。这是消息中间件最基本的特性之一，也就是我们通常所说的 “AT LEAST ONCE”，即**消息至少会被成功消费一遍。**

​	如果订单支付消息被重复消费，可能会导致业务逻辑的错误执行。例如，系统可能会多次发放优惠券、赠品或其他奖励，使得商家承担不必要的成本或资源浪费。



#### 分布式锁和 Token 令牌应用于防重复提交，去重表应对于消息重复防重复消费场景。

### 1. 分布式锁(http防重复提交)

当**用户提交请求时**，**服务器端可以生成一个唯一的标识，例如使用 UUID**。**(针对用户请求)**

在处理用户请求之前，服务器尝试获取一个分布式锁。如果成功获取到分布式锁，那么则执行接下来的正常业务逻辑流程。因为锁已经被获取，这样可以确保其他请求无法使用相同的标识，避免重复处理.

**在请求处理完成后，服务器需要释放分布式锁。**

**锁的颗粒度问题(初始锁列车即train_id)**



### 2. Token 令牌(防止服务重复调用)

为了防止**重复操作**，客户端在**第一次调用业务请求之前会发送一个获取 Token 的请求**。

在客户端进行第二次业务请求时，必须携带这个 Token。

服务端会验证这个 Token，如果验证成功，则执行业务逻辑并从 Redis 中删除该 Token。

如果验证失败，说明 Redis 中已经没有对应的 Token，表示重复操作，服务端会直接返回指定的结果给客户端

**第一次来无token ->存入redis(认定为第一次)**

**第二次及以后来有token -> 对比redis -> redis有,说明是第二次请求,把token删除**

​																**->redis没有,则说明已经删除过了**,**确定为重复操作**







### 消息队列如何保证不重复消费消息

//当使用消息队列时，客户端重复消费可能会成为一个严重的问题。
这是因为**消息队列具有持久性和可靠性**的特性，确保消息能够被成功传递给消费者。然而，这也会导致客户端在某些情况下**重复消费消息**，例如网络故障、客户端崩溃、消息处理失败等情况。如果消息队列中的同一消息被消费多次（可能由于消息系统重试机制触发），那么没有幂等性保证的系统可能会**重复扣款或重复分配座位**，导致数据错误和用户体验问题。



//为了避免这种情况发生，需要在**客户端实现一些机制**来确保消息不会被重复消费，例如记录**消费者已经处理的消息 ID**、使用**分布式锁来控制消费进程的唯一性**等。这些机制能够保证消息被成功处理，同时也能够提高系统的可靠性和稳定性。

### 3. 去重表

去重表是指在使用 Redis 或者 MySQL 作为存储时，为了实现幂等性而用于记录已经处理过的请求或操作，以防止重复执行。大部分场景下，**大家会使用 Redis 作为去重组件实现。**

​	客户端发送请求时，服务端会先查询 Redis 去重表来检查**该请求**是否已经被处理过。如果在存在对应的记录，表示请求已经执行过，服务端可以直接返回之，而不再执行重复操作。如果在不存在对应的记录，表示请求是新的，服务端会执行相应的业务逻辑，并在处理完成后将请求的唯一标识（如请求 ID 或标识）添加到 Redis 去重表中，以便后续的重复请求可以被正确识别和处理
