

1.瞬时高压和分布式锁压力问题

​	将没有出售的座位当作一个个令牌放到一个容器中,**也能缓解锁压力**

​	之前没有令牌容器进行过滤，所有请求都能进行到分布式锁这一步，加入令牌容器后，**只有少量拿到令牌的用户请求**可以获取分布式锁

主要做了三件事：

1. 如果令牌容器在缓存中失效需要重新读取并放入缓存；
2. 准备执行 Lua 脚本的数据；
3. 最终的执行 Lua 脚本获取令牌。

==(优化一:限流算法,引入毕设)==

![img](https://cdn.nlark.com/yuque/0/2023/png/331027/1693053704633-5e789ecd-30cd-4b64-86c2-48882d0064d6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_61%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

2.不是顺序购票

直接使用分布式锁不对,**存在业务上的问题**

这种情况就是因为默认 Redisson 的获取锁是非公平锁，这个概念和 ReentrantLock 中的非公平锁概念是一致的。(==针对具体的业务场景,公平锁实现,上线优化2==)



3.锁列车id还是太大了,假设 A 用户购买二等座、B 用户购买一等座以及 C 用户购买商务座，按照现有流程这三个用户的请求是串行的,按照现有流程这三个用户的请求是串行的

应该实现并行(==加锁颗粒度问题,本地锁加针对座位类型的分布式锁,上线优化3)==

双锁机制来实现:

本地锁,针对列车购票类型

分布式锁:防止多机运行



两个执行过程中可能出现的问题：

- 性能问题：本来用户购票只需要请求一次锁，现在却因为乘车人座位的多少，而决**定了会请求多加几次的锁**，存在一些性能问题。

- 执行时机：假设两个同时请求，张三刚获取了商务座和一等座的锁，因为并发的缘故，接下来李四获取到了二等座锁，这个时候张三哪怕已经获取到了两个座位的锁，也只能等待李四执行完座位分配后再执行。**因为获取锁是顺序的，所以不存在死锁情况**。

  如上所述，如果用户购买的座位过多，会被其他购买了单个座位的用户进行插队。





锁粒度优化更多是为了海量并发场景下的**抢票场景**，这种场景下，用户一般是不会选择多个座位的









### 1. 可否仅使用余票缓存做余票数量展示和限流效果？

这个是可以的，在大多数情况下，因为咱们技术方案比较复杂，有些面试官很难理解这个令牌限流。所以，我们可以使用传统秒杀架构，余票缓存直接扣减，然后再扣减数据库，就完成了所有流程。

### 2. 传统秒杀架构可能存在什么问题？