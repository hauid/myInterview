##### 限流的原因:

通过一个前置流程对无效流量进行限制，因为列车一共就那些票，你买的人再多，终归只有个别用户能成功，**多余的流量在前置购票环节直接返回**





**为什么建议 Redis+Lua 的方式？** 主要有两点原因：

- **减少了网络开销**：我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。
- **原子性**：一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。

**因为要操作多个 Hash Key，这个多站点的自减是非原子性的，所以我们需要通过 LUA 脚本完成**



一般减少超卖

####  Redis 缓存余量扣减

将商品 SKU 库存放到缓存，存储一个字符串或 Hash 类型。Key 是商品 SKU ID，Value 是商品 SKU 对应的库存数量，利用 Redis 的 incrby 特性来扣减库存，可以解决超扣和性能问题。



令牌限流容器里进行自减，**因为要操作多个 Hash Key，这个多站点的自减是非原子性的，所以我们需要通过 LUA 脚本完成**





### 技术实现方案

#### 1. Redis 缓存车票库存预先扣减

​	将列车余票放到缓存中，充当限流作用，通过 LUA 脚本扣减余票后，扣减成功代表余票数量充足，才可以进入流程分配座位，并创建订单，扣减失败请求打回。

​	因为扣减列车站点余票涉及到比较多的扣减关系，所以这里要使用 **LUA 脚本**。



#### 2. 构建库存令牌容器，拆分开限流和库存==(项目)==

相对于上一种方案，拆分了一个令牌容器，其中存放的**令牌就是列车余票数据**。如果用户购买车票，需要先扣减令牌容器，扣减成功代表余票数量充足，扣减失败请求打回。

用户查询列表所看到的余票数量，通过余票缓存，而不是令牌容器。

扣减令牌容器后，对余票缓存并没有影响，只有在修改了座位表后，才会通过 **Canal 形式监听并减少余票缓存**。



#### 为什么要拆分令牌容器？

因为有个极端情况，比如说，扣减余票缓存容器成功后，然后应用宕机，导致余票缓存和余票数据库库存不一致。

如果有令牌容器，发现没有剩余可用令牌，那么我们可以进行**兜底判断**，也可以叫做二次检查。触发一个请求去比对数据库是否还有值，如果有的话，那么就把令牌容器缓存删除，下个用户再购票时，重新加载即可。



#### 传统秒杀架构的问题

架构对比:

传统秒杀架构：在用户购买车票时，系统会先从余票缓存中扣减库存，然后再更新数据库，完成整个流程。

令牌容器架构：在用户购买车票时，首先从令牌容器（它代表了余票库存）中扣减令牌，然后再扣减数据库，并通过 Binlog 同步更新余票缓存。**用户看到的是余票缓存**，而令牌容器缓存则属于技术实现层面的内容，对用户透明。



对余票/库存为0的不同场景:

​	传统秒杀架构中，余票缓存被用来展示列车余票数量并进行限流，遇到极端场景时——例如扣减完余票缓存后，系统宕机，导致数据库未能成功更新——就可能出现前端展示余票为 0，但数据库中实际还有库存的情况。在这种情况下，就像电商平台的处理方式一样，余票为 0 的记录是不允许用户继续提交订单的。

​	使用令牌容器架构，遇到类似问题时，令牌余量为 0，余票缓存正常，数据库也正常。此时，只要余票缓存不为 0，哪怕**令牌容器中的令牌已耗尽**，也可以允许用户下单，并通过该操作触发令牌容器的刷新。



