#### 什么是缓存击穿？

缓存击穿是指一个缓存中的数据因为某种原因（通常是缓存中的数据过期或者被删除），在短时间内遭受大量的请求，导致这些请求直接穿透到数据库或其他后端存储系统，增加了后端系统的负载。

缓存击穿通常在以下情况下发生：

1. 热点数据过期：当缓存中存储的热门数据过期时，大量的请求会同时查询后端数据库。
2. 第一次请求：对于一个之前从未被请求过的数据，当它第一次被请求时，缓存中没有这个数据，从而导致请求穿透到后端存储。

#### 如何解决缓存击穿？

为了解决Redis缓存击穿问题，可以采取以下常见的方案：

1. 设置热点数据永不过期：对于一些热点数据，可以将其永不过期，确保即使数据过期后，仍然可以从缓存中获取。
2. 使用互斥锁：在获取数据时，使用分布式锁（如 Redis 的分布式锁）来控制同时**只有一个请求可以去后端获取数据**，其他请求需要等待锁释放。这样可以防止多个请求同时穿透到后端存储。





股票

社区

财富,资产管理



团队结构:几个团队 业务为主	中台:交易,支付	技术

基金:业务复杂,钱的操作

AI+服务,内容:思域,,推流





#### 1. 查询缓存不存在请求数据库

原始

#### 2. 分布式互斥锁优化数据库压力

普通锁

#### 3. 双重判定锁

上边还有一个问题就是，假如 100w 的请求读取一个缓存，100w 的请求全部卡在 lock.lock 获取分布式锁处，只有一个线程会执行逻辑请求数据库并放入缓存。问题来了，因为接下来的所有请求，99.99...w 还是会继续请求数据库，大家读一下上面的伪代码就明白了。

这会造成两个实际的问题：

1. 全部用户获取锁后查询数据库，会对数据库造成无用的性能浪费，因为这 100w 的请求，只有第一次是有效的。
2. 查询数据库会造成用户响应时间变长，接口吞吐量下降。

**双重判断：查询缓存不存在加锁请求数据库,取锁后，在查询数据库之前，再次检查一下缓存中是否存在数据。这是一个双重判断，如果缓存中存在数据，就直接返回；如果不存在，才继续执行查询数据库的操作。**

