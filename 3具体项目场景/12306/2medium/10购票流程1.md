

## 流程

### 0.对请求做预处理,幂等性组件

为了防止数据重复处理,资源浪费,业务逻辑错误

​	购票接口不做防重复提交处理，有可能会触发一个用户无意创建多个订单的可能。为了防止这种行为，需要针对购票接口做 HTTP 防重复提交处理

<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250305193311288.png" alt="image-20250305193311288" style="zoom:70%;" />



//3

### 1.开始:购票服务ticket service

//4

#### 1.1验证提交参数

我们需要在座位分配以及创建订单前，判断用户提交的参数以及用户是否可以购买车票

(**责任链模式**:多个处理器依次处理同一个请求,链表机制,一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条，**链条上的每个处理器各自承担各自的处理职责**)

判断购票情况:

1. 购票请求用户传递的**参数是否为空**，比如：车次 ID、乘车人、出发站点、到达站点等。
2. 购票请求用户传递的**参数是否正确**，比如：车次 ID 是否存在、出发和到达站点是否存在等。
3. 需要购票的车次**是否满足乘车人的数量**，也就是列车对应座位的余量是否充足。
4. 乘客**是否已购买当前车次**，或者乘客是否已购买当天时间冲突的车次。
5. **可能实际场景中需要验证的还有很多**，就不逐一举例了。

==(在这之后锁列车id,使用分布式锁)==



#### 1.2避免分配相同座位

 **Redisson 分布式锁**来解决这个问题。**同一列车在同一时间下仅有单个用户(业务需求)**可以进行座位分配以及创建订单行为，再加上 Redisson 分布式锁的自动续期等功能，可以很好保障系统运行稳定和脏数据问题。

- 后续分配座位

#### 1.3座位分配

**有具体的分配算法**

**结合背景三层逻辑**

优先满足两人并排

- 如果购票人数为两人，购买同一车厢，座位**优先检索两人相邻座位并排**分配。
- 假设当前正在检索的车厢不满足两人并排，就执行**搜索全部满足两人并排的车厢**。

满足不了就考虑同一车厢

- 如果搜索了所有车厢还是没有两人并排做的座位，那么执行**同车厢不相邻**座位。

最后不同车厢分配



如果所有车厢都是仅有一个座位，就开始执行最后降级操作，不同车厢分配。

#### 1.4.向队列组件发送延时取消消息(设置监听器,准备消费)

​	在订单生成时，我们将订单关闭消息发送到 RocketMQ，并设置消息的延迟时间为十分钟。RocketMQ 支持设置消息的延迟时间，可以通过设置消息的 delayLevel 来指定延迟级别，每个级别对应一种延迟时间。这样，订单关闭消息将在十分钟后自动被消费者接收到。

​	需要注意，RocketMQ 5.0 之后已经支持了自定义时间的延迟，而不仅是延迟级别范围内的时间。

为了处理订单关闭消息，我们需要在**消费者端创建一个消息监听器**。当消息监听器接收到订单关闭消息时，触发订单关闭操作，将订单状态设置为关闭状态。

​	需要注意的是，RocketMQ 的消息传递机制保证了消息的可靠性传递，因此消息可能会进行多次重试。为了确保订单关闭操作的幂等性，即多次执行不会产生副作用，我们需要在订单关闭逻辑中进行幂等性的处理。

因为 12306 系统中也使用到了 RocketMQ，所以这个解决方案将是咱们的不二选择。



### 2.**远程调用**:订单服务 order-service 

为乘车人分配好座位后，**没有问题的情况下，开始执行订单创建流程，**

通过 **SpringCloud OpenFeign**发起远程调用。

####  2.1订单号生成 (分库分表)->  

####  2.2创建订单记录(三类订单数据，分别是：主订单表、订单明细表以及订单乘车人明细表)->

- 主订单：用户购买的本次订单相关信息。
- 订单明细表：用户发起购票订单请求时，可能会为多名乘车人购票，每个乘车人会有对应的订单明细记录。
- 订单乘车人明细表：

####  2.3.订阅延迟关闭消息

​		用户发起订单后，如果长时间未支付，需要将订单关闭，也就是大家常说的**延时关闭订单**。

铁路 12306 系统中，使用 RocketMQ 作为延时关闭订单的技术实现，从整体考虑，处理能力以及稳定性相对来说较为合适。







#### tips

#### **延迟关闭订单(技术选型)**

**PowerJob等等定时任务**

这种方案的优点在于简单易实现，但是，该方案也存在一些问题：

1. **延迟时间不精确**：使用定时任务执行订单关闭逻辑，无法保证订单在十分钟后准确地关闭。如果任务执行器在关闭订单的具体时间点出现问题，可能导致订单关闭的时间延后。
2. 不适合**高并发场景**：定时任务执行的频率通常是固定的，无法根据实际订单的情况来灵活调整。在高并发场景下，可能导致**大量的定时任务同时执行，造成系统负载**过大。
3. 分库分表问题：拿 12306 来说，订单表按照**用户标识和订单号**进行了分库分表，那这样的话，和上面说的根据**订单创建时间去扫描一批订单进行关闭**，自然就行不通。因为根据创建时间查询没有携带分片键，存在**读扩散**问题。

通常最**不推荐的方式**是使用**定时任务**来实现订单关闭。



**RabbitMQ**

​	订单队列本身设置了消息的存活时间

​	订单队列和死信队列。**订单队列用于存储需要延时关闭的订单消息**，而死信交换机和死信队列则用于存储延时时间到达后的订单消息(**时间到了就将消息放到死信队列**)。在创建订单队列时，我们要为队列配置延时特性，指定订单消息的延时时间，比如十分钟。这样，当有新的订单需要延时关闭时，我们只需要将订单消息发送到订单队列，并设置消息的延时时间

​	在订单队列中**设置死信交换机和死信队列**，当订单消息的延时时间结束后，消息会自动转发到死信队列，从而触发关闭订单的操作。在死信队列中，我们可以监听消息，**并执行关闭订单的逻辑**。为了确保消息的可靠性，可以在关闭订单操作前添加适当的幂等性措施，这样即使消息重复处理，也不会对系统产生影响。



![image-20250310150624491](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310150624491.png)

![image-20250310150703577](C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250310150703577.png)



RabbitMQ 在**可用性**方面较弱，部分场景下会存在单点故障问题。













##### RocketMQ

​	生产者端:

- 订单关闭消息发送到 RocketMQ，并设置消息的延迟时间为十分钟。RocketMQ 支持设置消息的延迟时间，可以通过设置消息的 delayLevel 来指定延迟级别，每个级别对应一种延迟时间。这样，**订单关闭消息将在十分钟后自动被消费者接收到**

​	消费者端:

- 创建一个消息监听器。当消息监听器接收到订单关闭消息时，触发订单关闭操作，将订单状态设置为关闭状态







### 问题1

**延迟关闭订单发送端在订单服务，消费延迟关闭订单消息却是在购票服务**

**算法问题**

**确定顺序,有向图中存在环，导致拓扑排序算法无法进行。**

**影响**：

**无法确定节点的处理顺序（如任务调度、依赖解析）**



问题2

延迟队列是什么

- 延迟队列:死信交换机+死信队列+设置(订单)消息队列中消息存活时间

什么情况会成为死信

- 拒绝被消费
- 定时任务,如设置了(订单)消息队列中消息存活时间
- 订单队列满了

死信队列中如何操作

- 在死信队列中，我们可以监听消息，并执行关闭订单的逻辑。

怎么防止重复消费

- 









**生产者消费者模型**

**选型**

RabbitMQ 在可用性方面较弱，部分场景下会存在单点故障问题





RocketMQ，并设置消息的延迟时间为十分钟。RocketMQ 支持设置消息的延迟时间，可以通过设置消息的 **delayLevel** 来指定延迟级别，每个级别对应一种延迟时间。这样，订单关闭消息将在十分钟后自动被消费者接收到。