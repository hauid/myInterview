

### 背景





<img src="C:\Users\pqy\AppData\Roaming\Typora\typora-user-images\image-20250305193311288.png" alt="image-20250305193311288" style="zoom:80%;" />

#### 分类

幂等可能存在两种类型的问题：

- **接口幂等**：常说的接口防重复提交。
- **消息队列幂等**：如何保障**消息队列客户端对相同的消息仅消费一次**

##### 1. 接口防重复提交

如果**淘宝服务端**没有做相关防重复提交处理，那么就有可能生成多笔相同的订单。

如果做了幂等处理，除了第一次正常请求外，**第二次乃至更多次应该返回错误**，比如说提示语“重复提交失败”等；再或者返回“提交成功”，但是真正保存数据库的只有一次请求。具体使用哪一种需要看程序设计以及产品逻辑。

##### 2. 消息队列消费幂等

通常情况下，我们认为消息中间件是一个**可靠的组件**。这里的可靠性指的是，只要消息被成功投递到了消息中间件，它就不会丢失，至少能够**被消费者成功消费一次**。这是消息中间件最基本的特性之一，也就是我们通常所说的 “AT LEAST ONCE”，即**消息至少会被成功消费一遍。**

​	如果订单支付消息被重复消费，可能会导致业务逻辑的错误执行。例如，系统可能会多次发放优惠券、赠品或其他奖励，使得商家承担不必要的成本或资源浪费。



#### 分布式锁和 Token 令牌应用于防重复提交，去重表应对于消息重复防重复消费场景。

### 1. 分布式锁(http防重复提交)

背景:

- 防止用户多次点击导致重复请求



​	当**用户提交请求时**，**服务器端可以生成一个唯一的标识，例如使用 UUID**。**(针对用户请求)**

在处理用户请求之前，服务器尝试获取一个分布式锁。如果成功获取到分布式锁，那么则执行接下来的正常业务逻辑流程。因为锁已经被获取，这样可以确保其他请求无法使用相同的标识，避免重复处理.

**在请求处理完成后，服务器需要释放分布式锁。**

==**防止http重复提交,针对同一用户同一服务请求生成uuid**==



### 2. Token 令牌(防止服务重复调用)

背景:

- 防止因网络重试、客户端异常等导致的重复请求到达后端



为了防止**重复操作**，客户端在**第一次调用业务请求之前会发送一个获取 Token 的请求**。服务端会生成一个全局唯一的 ID 作为 Token，并将其保存在 Redis 中，同时将该 ID 返回给客户端。

在客户端进行第二次业务请求时，必须携带这个 Token。

服务端会验证这个 Token，如果验证成功，则执行业务逻辑并从 Redis 中删除该 Token。

如果验证失败，说明 Redis 中已经没有对应的 Token，表示重复操作，服务端会直接返回指定的结果给客户端.

#####  **生成 Token 的触发条件**

- **客户端首次请求**：不带 Token 的请求到达服务端，服务端通过 **身份 + 操作标识** 检查是否已存在有效 Token：
  - **不存在** → 生成 Token 并存入 Redis（Key 格式：`user:123:pay` 或 `device:abc:submit_order`）。
  - **已存在** → 拒绝生成新 Token，返回错误（如“操作进行中，请勿重复提交”）。

==防止请求重复调用,针对用户+服务请求生成token,重复的请求必定生成重复的token,得不到验证,返回"重复操作"==



##### **Redis Key 设计**

- **格式**：`防重前缀:身份标识:操作标识`
  - *示例*：
    - `anti_repeat:user:123:order_create`



### 消息队列如何保证不重复消费消息

//当使用消息队列时，客户端重复消费可能会成为一个严重的问题。
这是因为**消息队列具有持久性和可靠性**的特性，确保消息能够被成功传递给消费者。然而，这也会导致客户端在某些情况下**重复消费消息**，例如网络故障、客户端崩溃、消息处理失败等情况。如果消息队列中的同一消息被消费多次（可能由于消息系统重试机制触发），那么没有幂等性保证的系统可能会**重复扣款或重复分配座位**，导致数据错误和用户体验问题。



//为了避免这种情况发生，需要在**客户端实现一些机制**来确保消息不会被重复消费，例如记录**消费者已经处理的消息 ID**、使用**分布式锁来控制消费进程的唯一性**等。这些机制能够保证消息被成功处理，同时也能够提高系统的可靠性和稳定性。

### 3. 去重表

去重表是指在使用 Redis 或者 MySQL 作为存储时，为了实现幂等性而用于记录已经处理过的请求或操作，以防止重复执行。大部分场景下，**大家会使用 Redis 作为去重组件实现。**

​	客户端发送请求时，服务端会先查询 Redis 去重表来检查**该请求**是否已经被处理过。如果在存在对应的记录，表示请求已经执行过，服务端可以直接返回之，而不再执行重复操作。如果在不存在对应的记录，表示请求是新的，服务端会执行相应的业务逻辑，并在处理完成后将请求的唯一标识（如请求 ID 或标识）添加到 Redis 去重表中，以便后续的重复请求可以被正确识别和处理







#### **Token 令牌实现:**

aop底层是**反射**

使用 AOP 技术为方法增强提供了通用的幂等性保证，只需要在需要保证幂等性的方法上添加 `@Idempotent` 注解，`Aspect` 就会对该方法进行增强。

简单来说，就是先获取到方法上的幂等注解，然后获取到对应的幂等处理实现类。通过实现类进行幂等前置逻辑，执行完后操作具体被注解修饰的方法，最终执行释放资源的后置逻辑。

